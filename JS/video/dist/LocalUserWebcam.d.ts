import { DeviceSettingsChangedEvent, IDeviceSource, StreamChangedEvent } from "@juniper-lib/audio";
import { ElementChild, TypedHTMLElement } from "@juniper-lib/dom";
export declare class LocalUserWebcamElement extends TypedHTMLElement<{
    devicesettingschanged: DeviceSettingsChangedEvent;
    streamchanged: StreamChangedEvent;
}> implements HTMLVideoElement, IDeviceSource {
    #private;
    static observedAttributes: string[];
    attributeChangedCallback(name: string, _oldValue: string, newValue: string): void;
    constructor();
    get disablePictureInPicture(): boolean;
    set disablePictureInPicture(v: boolean);
    get width(): number;
    set width(v: number);
    get height(): number;
    set height(v: number);
    get videoWidth(): number;
    get videoHeight(): number;
    get onenterpictureinpicture(): (this: HTMLVideoElement, ev: Event) => any;
    set onenterpictureinpicture(v: (this: HTMLVideoElement, ev: Event) => any);
    get onleavepictureinpicture(): (this: HTMLVideoElement, ev: Event) => any;
    set onleavepictureinpicture(v: (this: HTMLVideoElement, ev: Event) => any);
    get playsInline(): boolean;
    set playsInline(v: boolean);
    get poster(): string;
    set poster(v: string);
    cancelVideoFrameCallback(handle: number): void;
    getVideoPlaybackQuality(): VideoPlaybackQuality;
    requestPictureInPicture(): Promise<PictureInPictureWindow>;
    requestVideoFrameCallback(callback: VideoFrameRequestCallback): number;
    get autoplay(): boolean;
    set autoplay(v: boolean);
    get buffered(): TimeRanges;
    get controls(): boolean;
    set controls(v: boolean);
    get crossOrigin(): string;
    set crossOrigin(v: string);
    get currentSrc(): string;
    get currentTime(): number;
    set currentTime(v: number);
    get defaultMuted(): boolean;
    set defaultMuted(v: boolean);
    get defaultPlaybackRate(): number;
    set defaultPlaybackRate(v: number);
    get disableRemotePlayback(): boolean;
    set disableRemotePlayback(v: boolean);
    get duration(): number;
    get ended(): boolean;
    get error(): MediaError;
    get loop(): boolean;
    set loop(v: boolean);
    get mediaKeys(): MediaKeys;
    get muted(): boolean;
    set muted(v: boolean);
    get networkState(): number;
    get onencrypted(): (this: HTMLMediaElement, ev: MediaEncryptedEvent) => any;
    set onencrypted(v: (this: HTMLMediaElement, ev: MediaEncryptedEvent) => any);
    get onwaitingforkey(): (this: HTMLMediaElement, ev: Event) => any;
    set onwaitingforkey(v: (this: HTMLMediaElement, ev: Event) => any);
    get paused(): boolean;
    get playbackRate(): number;
    set playbackRate(v: number);
    get played(): TimeRanges;
    get preload(): "" | "none" | "metadata" | "auto";
    set preload(v: "" | "none" | "metadata" | "auto");
    get preservesPitch(): boolean;
    set preservesPitch(v: boolean);
    get readyState(): number;
    get remote(): RemotePlayback;
    get seekable(): TimeRanges;
    get seeking(): boolean;
    get sinkId(): string;
    get src(): string;
    set src(v: string);
    get srcObject(): MediaProvider;
    set srcObject(v: MediaProvider);
    get textTracks(): TextTrackList;
    get volume(): number;
    set volume(v: number);
    addTextTrack(kind: TextTrackKind, label?: string, language?: string): TextTrack;
    canPlayType(type: string): CanPlayTypeResult;
    fastSeek(time: number): void;
    load(): void;
    pause(): void;
    play(): Promise<void>;
    setMediaKeys(mediaKeys: MediaKeys | null): Promise<void>;
    setSinkId(sinkId: string): Promise<void>;
    get NETWORK_EMPTY(): 0;
    get NETWORK_IDLE(): 1;
    get NETWORK_LOADING(): 2;
    get NETWORK_NO_SOURCE(): 3;
    get HAVE_NOTHING(): 0;
    get HAVE_METADATA(): 1;
    get HAVE_CURRENT_DATA(): 2;
    get HAVE_FUTURE_DATA(): 3;
    get HAVE_ENOUGH_DATA(): 4;
    get mozHasAudio(): boolean;
    set mozHasAudio(v: boolean);
    get webkitAudioDecodedByteCount(): number;
    set webkitAudioDecodedByteCount(v: number);
    get audioTracks(): unknown[];
    set audioTracks(v: unknown[]);
    get captureStream(): () => MediaStream;
    set captureStream(v: () => MediaStream);
    get mozCaptureStream(): () => MediaStream;
    set mozCaptureStream(v: () => MediaStream);
    connectedCallback(): void;
    get mediaType(): "audio" | "video";
    get deviceKind(): MediaDeviceKind;
    get enabled(): boolean;
    set enabled(v: boolean);
    get hasPermission(): boolean;
    get preferredDeviceID(): string;
    get device(): MediaDeviceInfo;
    checkDevices(devices: MediaDeviceInfo[]): void;
    setDevice(device: MediaDeviceInfo): Promise<void>;
    private onChange;
    get inStream(): MediaStream;
    set inStream(v: MediaStream);
    get outStream(): MediaStream;
    stop(): void;
    static install(): import("@juniper-lib/dom").ElementFactory<LocalUserWebcamElement>;
}
export declare function LocalUserWebcam(...rest: ElementChild<LocalUserWebcamElement>[]): LocalUserWebcamElement;
//# sourceMappingURL=LocalUserWebcam.d.ts.map