export type ComparisonResult = -1 | 0 | 1;
export type compareCallback<T> = ((a: T, b: T) => ComparisonResult) & Partial<{
    descending: boolean;
}>;
/**
 * Returns a new array holding the distinct values
 * in the input array, with no duplicates. Value identity
 * is determined by reference equality for objects.
 *
 * @param arr the array to de-duplicate
 * @param comparison a function to call when comparing objects by notional value instead of reference
 * @returns the de-duplicated array
 */
export declare function distinct<T>(arr: Readonly<ArrayLike<T>>, comparison?: compareCallback<T>): T[];
/**
 * Modes by which to handle runs of identical values when performing a binary search.
 */
export type BinarySearchMode = "append" | "prepend" | "search";
/**
 * Find the right insertion point to maintain a sorted array. If the value exists in the array, a positive index
 * value is returned. If it is not, a negative index is returned whose absolute value is one more than the correct
 * insertion index for the item in the array to be able to maintain the sort.
 *
 * This function also provides an option for how to handle runs of duplicate values. When more than one value
 * in the array matches the `searchValue`, the function will linearly scan to the beginning or end of, depending
 * on the value of `mode`. To skip scanning, provide the value "search" for mode.
 *
 * If coupled with {@link arrayInsert}, objects will be inserted into the correct position of the array without
 * any extra handling.
 *
 * NOTE: This expects sorted arrays and either a compare method generated by {@link compareBy}, or an array that
 * is not `length === 1`. When an array is `length === 1`, this function cannot determine if the array is sorted
 * ascending or descending. It will assume the array is ascending.
 *
 * @param arr the array to search
 * @param searchValue the value to search for
 * @param compare a callback function to select the value by which to search.
 * @param mode whether duplicates should go at the beginning or end of the run
 */
export declare function binarySearch<T>(arr: ArrayLike<T>, searchValue: T, compare: compareCallback<T>, mode: BinarySearchMode): number;
/**
 * Insert an item into an array, making sure to handle the return value of binarySearch correctly
 * @param arr
 * @param item
 * @param index
 * @returns the index at which the item was inserted.
 */
export declare function arrayInsert<T>(arr: T[], item: T, index: number): number;
export type InsertMode = "set" | BinarySearchMode;
export declare function insertSorted<T>(arr: T[], val: T, idx: number): number;
export declare function insertSorted<T>(arr: T[], val: T, comparer: compareCallback<T>): number;
export declare function insertSorted<T>(arr: T[], val: T, comparer: compareCallback<T>, mode: InsertMode): number;
export declare function removeSorted<T>(arr: T[], val: T, comparer: compareCallback<T>): number;
/**
 * Chain comparisons together to drill down on additional details when the previous comparisons
 * evaulated to being equivalent.
 */
export declare function compareSequence<T>(...comparers: compareCallback<T>[]): compareCallback<T>;
/**
 * For sorting by the value returned by a callback function.
 * @label GETTERS
 * @param ascending
 * @param getters
 */
export declare function compareBy<T>(...getters: ((item: T) => any)[]): compareCallback<T>;
/**
 * For sorting by the value returned by a callback function.
 * @label WITH_ASCENDING
 * @param getters
 */
export declare function compareBy<T>(ascending: boolean, ...getters: ((item: any) => any)[]): compareCallback<T>;
/**
 * Returns a random item from an array of items.
 *
 * Provides an option to consider an additional item as part of the collection
 * for random selection.
 */
export declare function arrayRandom<T>(arr: T[], defaultValue?: T): T | undefined;
/**
 * Removes an item from an array.
 * @param arr the array from which to remove the item
 * @param item the item to remove from the array
 * @returns the original array
 */
export declare function arrayRemove<T>(arr: T[], item: T): T[];
/**
 * Filters an array in place.
 * @param arr the array from which to remove the item
 * @param item the item to remove from the array
 * @returns the original array
 */
export declare function arrayFilter<T>(arr: T[], predicate: (value: T) => boolean): T[];
/**
 * Clear an array of all contents.
 * @param arr
 * @returns the items that were removed from the array
 */
export declare function arrayClear<T>(arr: T[]): T[];
/**
 * Generates a sequence of numbers
 * @param min inclusive lower bound
 * @param max exclusive upper bound
 */
export declare function generate(min: number, max: number): number[];
/**
 * Checks to see if two arrays contain the same elements. If they match, the return value is -1.
 * @param arr1
 * @param arr2
 * @returns -1 if the arrays match, the index of the first mismatched item if they don't.
 */
export declare function arrayCompare<T>(arr1: ArrayLike<T>, arr2: ArrayLike<T>): number;
/**
 * A record of differences of two arrays.
 */
export declare class Diff {
    readonly inA: string[];
    readonly inB: string[];
    readonly notEquals: string[];
    constructor(inA: string[], inB: string[], notEquals: string[]);
}
/**
 * Converts rows into columns and vice versa for rectangular arrays
 */
export declare function pivot<T>(grid: T[][]): T[][];
/**
 * Scans through a series of filters to find an item that matches
 * any of the filters. The first item of the first filter that matches
 * will be returned.
 */
export declare function arrayScan<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;
export declare function arrayScan<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T;
/**
 * Scans through a series of filters to find an item that matches
 * any of the filters. The last item of the first filter that matches
 * will be returned.
 */
export declare function arrayScanReverse<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;
export declare function arrayScanReverse<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T;
export declare function arrayShuffleInplace<T>(arr: T[]): void;
export declare function arrayShuffle<T>(arr: readonly T[]): T[];
/**
 * Compress an array of items that have duplicates in groups
 * down to an array of items with the number of items in
 * a run group
 * @param items
 */
export declare function arrayGetRunLengths<T>(items: ArrayLike<T>): [T, number][];
/**
 * Clears an array and inserts a new set of items into it.
 * @returns an array of the items that were replaced.
 */
export declare function arrayReplace<T>(arr: T[], newItems: ArrayLike<T>): T[];
/**
 * Coallesces an iterator into an array, defaulting a null iterator
 * to an empty array.
 */
export declare function iterate<T>(iter: IterableIterator<T>): T[];
/**
 * Returns the first element of an array
 */
export declare function first<T>(arr: ArrayLike<T>): T;
/**
 * Iterate over an array and combine neighbors into pairs.
 * E.g. `[1, 2, 3, 4, 5, 6]` => `[[1, 2], [3, 4], [5, 6]]`.
 *
 * NOTE: if an array of odd-length is provided, the last item will
 * be dropped, having nothing with which to pair.
 */
export declare function pair<T>(arr: T[]): [T, T][];
/**
 * Returns the last element of an array
 */
export declare function last<T>(arr: ArrayLike<T>): T;
/**
 * Returns a new array that is the same as the old array, minus the first item.
 */
export declare function rest<T>(arr: ArrayLike<T>): T[];
/**
 * Returns the sum of a given property extracted from an array of objects
 */
export declare function sum<T extends object, K extends keyof T>(objs: T[], property: K): number;
/**
 * Returns all the non-array items in a deeply nested array  set.
 * @param values
 * @returns
 */
export declare function flatten<T extends {
    children: T[];
}>(values: ArrayLike<T>): T[];
/**
 * Groups array items by a key
 * @param items the items to group
 * @param getKey a callback to select the field by which to group items
 */
export declare function groupBy<T, K>(items: T[], getKey: (item: T) => K): Map<K, T[]>;
export declare function groupBy<T, K, V>(items: T[], getKey: (item: T) => K, getValue?: (item: T) => V): Map<K, V[]>;
export declare function select(arr: any[], fieldDef: string): unknown[];
//# sourceMappingURL=arrays.d.ts.map