import { identity } from "./filters";
import { objectSelect } from "./objects";
import { isDefined, isNullOrUndefined, isNumber } from "./typeChecks";
/**
 * Returns a new array holding the distinct values
 * in the input array, with no duplicates. Value identity
 * is determined by reference equality for objects.
 *
 * @param arr the array to de-duplicate
 * @param comparison a function to call when comparing objects by notional value instead of reference
 * @returns the de-duplicated array
 */
export function distinct(arr, comparison) {
    comparison = comparison || compareBy(identity);
    const arrOut = new Array();
    for (let i = 0; i < arr.length; ++i) {
        const item = arr[i];
        const index = binarySearch(arrOut, item, comparison, "search");
        if (index < 0) {
            arrayInsert(arrOut, item, index);
        }
    }
    return arrOut;
}
/**
 * Find the right insertion point to maintain a sorted array. If the value exists in the array, a positive index
 * value is returned. If it is not, a negative index is returned whose absolute value is one more than the correct
 * insertion index for the item in the array to be able to maintain the sort.
 *
 * This function also provides an option for how to handle runs of duplicate values. When more than one value
 * in the array matches the `searchValue`, the function will linearly scan to the beginning or end of, depending
 * on the value of `mode`. To skip scanning, provide the value "search" for mode.
 *
 * If coupled with {@link arrayInsert}, objects will be inserted into the correct position of the array without
 * any extra handling.
 *
 * NOTE: This expects sorted arrays and either a compare method generated by {@link compareBy}, or an array that
 * is not `length === 1`. When an array is `length === 1`, this function cannot determine if the array is sorted
 * ascending or descending. It will assume the array is ascending.
 *
 * @param arr the array to search
 * @param searchValue the value to search for
 * @param compare a callback function to select the value by which to search.
 * @param mode whether duplicates should go at the beginning or end of the run
 */
export function binarySearch(arr, searchValue, compare, mode) {
    if (!arr) {
        throw new Error("Input array is null");
    }
    if (arr.length === 0) {
        // degenerate case where array is empty
        return -1;
    }
    let left = 0;
    let right = arr.length - 1;
    // When modifying this function, uncomment these lines to detect
    // erroneous infinite loop cases. When the tests pass, you can
    // comment these lines out.
    // let lastLow = null;
    // let lastHigh = null;
    while (left <= right) {
        // When modifying this function, uncomment these lines to detect
        // erroneous infinite loop cases. When the tests pass, you can
        // comment these lines out.
        // if (low === lastLow
        //     && high === lastHigh) {
        //     throw new Error("Infinite loop");
        // }
        // lastLow = low;
        // lastHigh = high;
        let mid = (left + right) >> 1;
        let relation = compare(arr[mid], searchValue);
        if (relation === 0) {
            if (mode !== "search") {
                const scanDirection = mode === "append" ? 1 : -1;
                if (scanDirection > 0) {
                    mid += scanDirection;
                }
                while (0 <= mid
                    && mid < arr.length
                    && (relation = compare(arr[mid], searchValue)) === 0) {
                    mid += scanDirection;
                }
                if (scanDirection < 0) {
                    mid -= scanDirection;
                }
            }
            return mid;
        }
        else if (relation < 0) {
            left = mid - relation;
        }
        else {
            right = mid - relation;
        }
    }
    return -left - 1;
}
/**
 * Insert an item into an array, making sure to handle the return value of binarySearch correctly
 * @param arr
 * @param item
 * @param index
 * @returns the index at which the item was inserted.
 */
export function arrayInsert(arr, item, index) {
    if (index < 0) {
        index = -index - 1;
    }
    arr.splice(index, 0, item);
    return index;
}
export function insertSorted(arr, val, comparerOrIdx, mode = "search") {
    const allowDuplicates = mode !== "set";
    if (mode === "set") {
        mode = "search";
    }
    let idx = null;
    if (isNumber(comparerOrIdx)) {
        idx = comparerOrIdx;
    }
    else {
        idx = binarySearch(arr, val, comparerOrIdx, mode);
    }
    if (idx < 0) {
        idx = -idx - 1;
    }
    else if (!allowDuplicates) {
        return -1;
    }
    arrayInsert(arr, val, idx);
    return idx;
}
export function removeSorted(arr, val, comparer) {
    const idx = binarySearch(arr, val, comparer, "search");
    if (idx >= 0) {
        arr.splice(idx, 1);
        return idx;
    }
    return -1;
}
/**
 * Chain comparisons together to drill down on additional details when the previous comparisons
 * evaulated to being equivalent.
 */
export function compareSequence(...comparers) {
    return (a, b) => {
        let result = 0;
        for (const comparer of comparers) {
            result = comparer(a, b);
            if (result !== 0) {
                break;
            }
        }
        return result;
    };
}
export function compareBy(ascendingOrFirstGetter, ...getters) {
    let ascending = true;
    if (typeof ascendingOrFirstGetter === "boolean") {
        ascending = ascendingOrFirstGetter;
    }
    else if (isDefined(ascendingOrFirstGetter)) {
        getters.unshift(ascendingOrFirstGetter);
    }
    if (getters.length === 0) {
        return null;
    }
    const d = ascending ? 1 : -1;
    const comparer = (a, b) => {
        if (a === b) {
            return 0;
        }
        for (const getter of getters) {
            const keyA = fixComparisonKey(isDefined(a) ? getter(a) : null);
            const keyB = fixComparisonKey(isDefined(b) ? getter(b) : null);
            let relation;
            if (keyA === keyB
                || Number.isNaN(keyA) && Number.isNaN(keyB)) {
                relation = 0;
            }
            else if ((typeof keyA === "string") && (typeof keyB === "string")) {
                relation = d * keyA.localeCompare(keyB);
            }
            else if (isGreater(keyA, keyB)) {
                relation = d;
            }
            else if (isGreater(keyB, keyA)) {
                relation = -d;
            }
            else {
                relation = 0;
            }
            if (relation < 0) {
                return -1;
            }
            else if (relation > 0) {
                return 1;
            }
        }
        return 0;
    };
    return Object.assign(comparer, {
        descending: !ascending
    });
}
function fixComparisonKey(key) {
    if (key instanceof Date) {
        key = key.getTime();
    }
    return key;
}
function isGreater(keyA, keyB) {
    return keyB === null
        || keyB === undefined
        || Number.isNaN(keyB)
        || keyA > keyB;
}
/**
 * Returns a random item from an array of items.
 *
 * Provides an option to consider an additional item as part of the collection
 * for random selection.
 */
export function arrayRandom(arr, defaultValue) {
    const offset = defaultValue != null ? 1 : 0, idx = Math.floor(Math.random() * (arr.length + offset)) - offset;
    if (idx < 0) {
        return defaultValue;
    }
    else {
        return arr[idx];
    }
}
/**
 * Removes an item from an array.
 * @param arr the array from which to remove the item
 * @param item the item to remove from the array
 * @returns the original array
 */
export function arrayRemove(arr, item) {
    const index = arr.indexOf(item);
    if (index >= 0) {
        arr.splice(index, 1);
    }
    return arr;
}
/**
 * Filters an array in place.
 * @param arr the array from which to remove the item
 * @param item the item to remove from the array
 * @returns the original array
 */
export function arrayFilter(arr, predicate) {
    for (let i = arr.length - 1; i >= 0; --i) {
        if (predicate(arr[i])) {
            arr.splice(i, 1);
        }
    }
    return arr;
}
/**
 * Clear an array of all contents.
 * @param arr
 * @returns the items that were removed from the array
 */
export function arrayClear(arr) {
    return arr.splice(0, arr.length);
}
/**
 * Generates a sequence of numbers
 * @param min inclusive lower bound
 * @param max exclusive upper bound
 */
export function generate(min, max) {
    if (min > max) {
        throw new Error("Minimum must be less than maximum.");
    }
    function* _range() {
        for (let i = min; i < max; ++i) {
            yield i;
        }
    }
    return Array.from(_range());
}
/**
 * Checks to see if two arrays contain the same elements. If they match, the return value is -1.
 * @param arr1
 * @param arr2
 * @returns -1 if the arrays match, the index of the first mismatched item if they don't.
 */
export function arrayCompare(arr1, arr2) {
    if (isNullOrUndefined(arr1) !== isNullOrUndefined(arr2)) {
        return 0;
    }
    if (isNullOrUndefined(arr1) && isNullOrUndefined(arr2)) {
        return -1;
    }
    if (arr1.length !== arr2.length) {
        return Math.max(arr1.length, arr2.length);
    }
    for (let i = 0; i < arr1.length; ++i) {
        if (arr1[i] !== arr2[i]) {
            return i;
        }
    }
    return -1;
}
/**
 * A record of differences of two arrays.
 */
export class Diff {
    constructor(inA, inB, notEquals) {
        this.inA = inA;
        this.inB = inB;
        this.notEquals = notEquals;
    }
}
/**
 * Converts rows into columns and vice versa for rectangular arrays
 */
export function pivot(grid) {
    const height = grid.length;
    const width = Math.max(...grid.map(row => row.length));
    const output = new Array(width);
    for (let y = 0; y < grid.length; ++y) {
        const row = grid[y];
        for (let x = 0; x < row.length; ++x) {
            if (y === 0) {
                output[x] = new Array(height);
            }
            output[x][y] = grid[y][x];
        }
    }
    return output;
}
function _arrayScan(forward, arr, tests) {
    const start = forward ? 0 : arr.length - 1;
    const end = forward ? arr.length : -1;
    const inc = forward ? 1 : -1;
    for (const test of tests) {
        for (let i = start; i != end; i += inc) {
            const item = arr[i];
            if (test(item)) {
                return item;
            }
        }
    }
    return null;
}
export function arrayScan(arr, ...tests) {
    return _arrayScan(true, arr, tests);
}
export function arrayScanReverse(arr, ...tests) {
    return _arrayScan(false, arr, tests);
}
export function arrayShuffleInplace(arr) {
    for (let i = 0; i < arr.length - 1; ++i) {
        const subLength = arr.length - i;
        const subIndex = Math.floor(Math.random() * subLength);
        const temp = arr[i];
        const j = subIndex + i;
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
export function arrayShuffle(arr) {
    const output = arr.slice();
    arrayShuffleInplace(output);
    return output;
}
/**
 * Compress an array of items that have duplicates in groups
 * down to an array of items with the number of items in
 * a run group
 * @param items
 */
export function arrayGetRunLengths(items) {
    const runs = [];
    let curRunItem = null;
    let curRunLength = 0;
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        if (item === curRunItem) {
            ++curRunLength;
        }
        else {
            if (curRunLength > 0) {
                runs.push([curRunItem, curRunLength]);
            }
            curRunItem = item;
            curRunLength = 1;
        }
    }
    if (curRunLength > 0) {
        runs.push([curRunItem, curRunLength]);
    }
    return runs;
}
/**
 * Clears an array and inserts a new set of items into it.
 * @returns an array of the items that were replaced.
 */
export function arrayReplace(arr, newItems) {
    return arr.splice(0, arr.length, ...Array.from(newItems));
}
/**
 * Coallesces an iterator into an array, defaulting a null iterator
 * to an empty array.
 */
export function iterate(iter) {
    return iter && Array.from(iter) || [];
}
/**
 * Returns the first element of an array
 */
export function first(arr) {
    return arr[0];
}
/**
 * Iterate over an array and combine neighbors into pairs.
 * E.g. `[1, 2, 3, 4, 5, 6]` => `[[1, 2], [3, 4], [5, 6]]`.
 *
 * NOTE: if an array of odd-length is provided, the last item will
 * be dropped, having nothing with which to pair.
 */
export function pair(arr) {
    function* _pair() {
        for (let i = 0; i < arr.length; i += 2) {
            yield [arr[i], arr[i + 1]];
        }
    }
    return Array.from(_pair());
}
/**
 * Returns the last element of an array
 */
export function last(arr) {
    return arr[arr.length - 1];
}
/**
 * Returns a new array that is the same as the old array, minus the first item.
 */
export function rest(arr) {
    const newArr = Array.from(arr);
    newArr.shift();
    return newArr;
}
/**
 * Returns the sum of a given property extracted from an array of objects
 */
export function sum(objs, property) {
    return objs.reduce(function (a, b) {
        return a + b[property];
    }, 0);
}
/**
 * Returns all the non-array items in a deeply nested array  set.
 * @param values
 * @returns
 */
export function flatten(values) {
    const q = Array.from(values);
    const all = [];
    while (q.length > 0) {
        const here = q.shift();
        all.push(here);
        if (here.children.length > 0) {
            q.push(...here.children);
        }
    }
    return all.reverse();
}
export function groupBy(items, getKey, getValue) {
    getValue = getValue ?? identity;
    const map = new Map();
    for (const item of items) {
        const key = getKey(item);
        if (!map.has(key)) {
            map.set(key, []);
        }
        map.get(key).push(getValue(item));
    }
    return map;
}
export function select(arr, fieldDef) {
    return arr.map(obj => objectSelect(obj, fieldDef));
}
//# sourceMappingURL=arrays.js.map