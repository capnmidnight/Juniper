import { IDisposable } from "@juniper-lib/util";
import { IProgress } from "@juniper-lib/progress";
import { JuniperAudioContext } from "../context/JuniperAudioContext";
import { FullAudioRecord } from "../data";
import { BaseSpatializer } from "../spatializers/BaseSpatializer";
import { BaseAudioSource } from "./BaseAudioSource";
import { IPlayer, MediaPlayerEvents } from "./IPlayer";
import { PlaybackState } from "./PlaybackState";
export declare class AudioPlayer extends BaseAudioSource<MediaPlayerEvents<FullAudioRecord>> implements IPlayer<FullAudioRecord>, IDisposable {
    private readonly cacheBustSources;
    private readonly audioElement;
    private readonly loadingEvt;
    private readonly loadEvt;
    private readonly playEvt;
    private readonly pauseEvt;
    private readonly stopEvt;
    private readonly progEvt;
    private readonly onError;
    private readonly onPlay;
    private readonly onCanPlay;
    private readonly onWaiting;
    private readonly onPause;
    private readonly onTimeUpdate;
    private _data;
    get data(): FullAudioRecord | string;
    private _loaded;
    get loaded(): boolean;
    get title(): string;
    protected setTitle(v: string): void;
    private readonly sourcesByURL;
    private readonly sources;
    private readonly potatoes;
    constructor(context: JuniperAudioContext, spatializer: BaseSpatializer);
    get hasAudio(): boolean;
    protected onDisposing(): void;
    clear(): void;
    cacheBust(data: FullAudioRecord | string): void;
    load(data: FullAudioRecord | string, prog?: IProgress): Promise<this>;
    private getMediaCapabilities;
    private get hasSources();
    private loadAudio;
    get playbackState(): PlaybackState;
    play(): Promise<void>;
    playThrough(): Promise<void>;
    pause(): void;
    stop(): void;
    restart(): Promise<void>;
    get element(): HTMLAudioElement;
}
//# sourceMappingURL=AudioPlayer.d.ts.map