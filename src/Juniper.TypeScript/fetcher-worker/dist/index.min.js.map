{
  "version": 3,
  "sources": ["../../tslib/typeChecks.ts", "../../tslib/collections/arrayRemoveAt.ts", "../../tslib/collections/arrayClear.ts", "../../tslib/events/EventBase.ts", "../../tslib/collections/mapJoin.ts", "../../tslib/flags.ts", "../../tslib/gis/Datum.ts", "../../tslib/math/angleClamp.ts", "../../tslib/progress/BaseProgress.ts", "../../tslib/progress/ChildProgressCallback.ts", "../../tslib/progress/BaseParentProgressCallback.ts", "../../tslib/progress/IProgress.ts", "../../tslib/progress/progressPopper.ts", "../../tslib/workers/WorkerClient.ts", "../../tslib/workers/WorkerPool.ts", "../../tslib/workers/WorkerServer.ts", "../../fetcher-base/ResponseTranslator.ts", "../../fetcher-base/FetchingServiceImpl.ts", "../src/FetchingServiceServer.ts", "../src/index.ts"],
  "sourcesContent": ["function t(o: any, s: string, c: Function) {\r\n    return typeof o === s\r\n        || o instanceof c;\r\n}\r\n\r\nexport function isFunction(obj: any): obj is Function {\r\n    return t(obj, \"function\", Function);\r\n}\r\n\r\nexport function isString(obj: any): obj is string {\r\n    return t(obj, \"string\", String);\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n    return t(obj, \"boolean\", Boolean);\r\n}\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n    return t(obj, \"number\", Number);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is not the special NaN value.\r\n */\r\nexport function isGoodNumber(obj: any): obj is number {\r\n    return isNumber(obj)\r\n        && !Number.isNaN(obj);\r\n}\r\n\r\nexport function isObject(obj: any): obj is object {\r\n    return isDefined(obj)\r\n        && t(obj, \"object\", Object);\r\n}\r\n\r\nexport function isPromise<T>(obj: any): obj is Promise<T> {\r\n    return obj instanceof Promise;\r\n}\r\n\r\nexport function isDate(obj: any): obj is Date {\r\n    return obj instanceof Date;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n    return obj instanceof Array;\r\n}\r\n\r\nexport function assertNever(x: never, msg?: string): never {\r\n    throw new Error((msg || \"Unexpected object: \") + x);\r\n}\r\n\r\nexport function isNullOrUndefined<T>(obj: T | null | undefined): obj is null | undefined {\r\n    return obj === null\r\n        || obj === undefined;\r\n}\r\n\r\nexport function isDefined<T>(obj: T | null | undefined): obj is T {\r\n    return !isNullOrUndefined(obj);\r\n}\r\n\r\nexport function isEventListener(obj: EventListenerOrEventListenerObject): obj is EventListener {\r\n    return isFunction(obj);\r\n}\r\n\r\nexport function isEventListenerObject(obj: EventListenerOrEventListenerObject): obj is EventListenerObject {\r\n    return !isEventListener(obj);\r\n}\r\n\r\nexport function isArrayBufferView(obj: any): obj is ArrayBufferView {\r\n    return obj instanceof Uint8Array\r\n        || obj instanceof Uint8ClampedArray\r\n        || obj instanceof Int8Array\r\n        || obj instanceof Uint16Array\r\n        || obj instanceof Int16Array\r\n        || obj instanceof Uint32Array\r\n        || obj instanceof Int32Array\r\n        || obj instanceof Float32Array\r\n        || obj instanceof Float64Array\r\n        || \"BigUint64Array\" in globalThis && obj instanceof globalThis[\"BigUint64Array\"]\r\n        || \"BigInt64Array\" in globalThis && obj instanceof globalThis[\"BigInt64Array\"];\r\n}\r\n\r\nexport function isHTMLElement(obj: any): obj is HTMLElement {\r\n    return obj instanceof HTMLElement;\r\n}\r\n\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\nexport function isXHRBodyInit(obj: any): obj is BodyInit {\r\n    return isString(obj)\r\n        || isArrayBufferView(obj)\r\n        || obj instanceof Blob\r\n        || obj instanceof FormData\r\n        || isArrayBuffer(obj)\r\n        || obj instanceof ReadableStream\r\n        || \"Document\" in globalThis && obj instanceof Document;\r\n}", "/**\r\n * Removes an item at the given index from an array.\r\n */\r\nexport function arrayRemoveAt<T>(arr: T[], idx: number) {\r\n    return arr.splice(idx, 1)[0];\r\n}", "/**\r\n * Empties out an array, returning the items that were in the array.\r\n * \r\n * @param arr the array to empty\r\n */\r\nexport function arrayClear<T>(arr: T[]) {\r\n    return arr.splice(0);\r\n}", "import { arrayClear } from \"../collections/arrayClear\";\r\nimport { arrayRemoveAt } from \"../collections/arrayRemoveAt\";\r\nimport { isBoolean, isDefined, isFunction, isNullOrUndefined } from \"../typeChecks\";\r\n\r\nconst allListeners = new WeakMap<EventBase, Map<string, Function[]>>();\r\n\r\nexport class EventBase implements EventTarget {\r\n    private readonly listeners = new Map<string, Function[]>();\r\n    private readonly listenerOptions = new Map<Function, boolean | AddEventListenerOptions>();\r\n\r\n    constructor() {\r\n        allListeners.set(this, this.listeners);\r\n    }\r\n\r\n    addEventListener(type: string, callback: (evt: Event) => any, options?: boolean | AddEventListenerOptions): void {\r\n        if (isFunction(callback)) {\r\n            let listeners = this.listeners.get(type);\r\n            if (!listeners) {\r\n                listeners = new Array<Function>();\r\n                this.listeners.set(type, listeners);\r\n            }\r\n\r\n            if (!listeners.find(c => c === callback)) {\r\n                listeners.push(callback);\r\n\r\n                if (options) {\r\n                    this.listenerOptions.set(callback, options);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (evt: Event) => any) {\r\n        if (isFunction(callback)) {\r\n            const listeners = this.listeners.get(type);\r\n            if (listeners) {\r\n                this.removeListener(listeners, callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeListener(listeners: Function[], callback: Function) {\r\n        const idx = listeners.findIndex(c => c === callback);\r\n        if (idx >= 0) {\r\n            arrayRemoveAt(listeners, idx);\r\n            if (this.listenerOptions.has(callback)) {\r\n                this.listenerOptions.delete(callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(evt: Event): boolean {\r\n        const listeners = this.listeners.get(evt.type);\r\n        if (listeners) {\r\n            for (const callback of listeners) {\r\n                const options = this.listenerOptions.get(callback);\r\n                if (isDefined(options)\r\n                    && !isBoolean(options)\r\n                    && options.once) {\r\n                    this.removeListener(listeners, callback);\r\n                }\r\n\r\n                callback.call(this, evt);\r\n            }\r\n        }\r\n        return !evt.defaultPrevented;\r\n    }\r\n}\r\n\r\nexport class TypedEvent<T extends string> extends Event {\r\n\r\n    override get type(): T {\r\n        return super.type as T;\r\n    }\r\n\r\n    constructor(type: T) {\r\n        super(type);\r\n    }\r\n}\r\n\r\nexport class TypedEventBase<EventsT> extends EventBase {\r\n    private readonly bubblers = new Set<TypedEventBase<EventsT>>();\r\n    private readonly scopes = new WeakMap<object, Array<[any, any]>>();\r\n\r\n    addBubbler(bubbler: TypedEventBase<EventsT>) {\r\n        this.bubblers.add(bubbler);\r\n    }\r\n\r\n    removeBubbler(bubbler: TypedEventBase<EventsT>) {\r\n        this.bubblers.delete(bubbler);\r\n    }\r\n\r\n    override addEventListener<K extends keyof EventsT & string>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any, options?: boolean | AddEventListenerOptions): void {\r\n        super.addEventListener(type, callback as any, options);\r\n    }\r\n\r\n    override removeEventListener<K extends keyof EventsT & string>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any) {\r\n        super.removeEventListener(type, callback as any);\r\n    }\r\n\r\n    addScopedEventListener<K extends keyof EventsT & string>(scope: object, type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any, options?: boolean | AddEventListenerOptions): void {\r\n        if (!this.scopes.has(scope)) {\r\n            this.scopes.set(scope, []);\r\n        }\r\n        this.scopes.get(scope).push([type, callback]);\r\n        this.addEventListener(type, callback as any, options);\r\n    }\r\n\r\n    removeScope<K extends keyof EventsT & string>(scope: object) {\r\n        const listeners = this.scopes.get(scope);\r\n        if (listeners) {\r\n            this.scopes.delete(scope);\r\n            for (const [type, listener] of listeners) {\r\n                this.removeEventListener(type as K, listener);\r\n            }\r\n        }\r\n    }\r\n\r\n    clearEventListeners<K extends keyof EventsT & string>(type?: K) {\r\n        const listeners = allListeners.get(this);\r\n        for (const [evtName, handlers] of listeners) {\r\n            if (isNullOrUndefined(type) || type === evtName) {\r\n                arrayClear(handlers);\r\n                listeners.delete(evtName);\r\n            }\r\n        }\r\n    }\r\n\r\n    override dispatchEvent<T extends Event>(evt: T): boolean {\r\n        if (!super.dispatchEvent(evt)) {\r\n            return false;\r\n        }\r\n\r\n        for (const bubbler of this.bubblers) {\r\n            if (!bubbler.dispatchEvent(evt)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}", "import { isDefined } from \"../typeChecks\";\r\n\r\nexport function mapJoin<KeyT, ValueT>(dest: Map<KeyT, ValueT>, ...sources: Map<KeyT, ValueT>[]): Map<KeyT, ValueT> {\r\n    for (const source of sources) {\r\n        if (isDefined(source)) {\r\n            for (const [key, value] of source) {\r\n                dest.set(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n", "export function isChrome() {\r\n    return \"chrome\" in globalThis && !navigator.userAgent.match(\"CriOS\");\r\n}\r\n\r\nexport function isFirefox() {\r\n    return \"InstallTrigger\" in globalThis;\r\n}\r\n\r\nexport function isSafari() {\r\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n}\r\n\r\nexport function isMacOS() {\r\n    return /^mac/i.test(navigator.platform);\r\n}\r\n\r\nexport function isIOS() {\r\n    return /iP(ad|hone|od)/.test(navigator.platform)\r\n        || /Macintosh(.*?) FxiOS(.*?)\\//.test(navigator.platform)\r\n        || isMacOS()\r\n            && \"maxTouchPoints\" in navigator\r\n            && (navigator as any).maxTouchPoints > 2;\r\n}\r\n\r\nexport function isApple() {\r\n    return isIOS()\r\n        || isMacOS();\r\n}\r\n\r\nexport function isMobileVR() {\r\n    return /Mobile VR/.test(navigator.userAgent)\r\n        || isOculusBrowser;\r\n}\r\n\r\nexport function hasWebXR() {\r\n    return \"xr\" in navigator\r\n        && \"isSessionSupported\" in (navigator as any).xr;\r\n}\r\n\r\nexport function hasWebVR() {\r\n    return \"getVRDisplays\" in navigator;\r\n}\r\n\r\nexport function hasVR() {\r\n    return hasWebXR() || hasWebVR();\r\n}\r\n\r\nexport function isMobile() {\r\n    return /Android/.test(navigator.userAgent)\r\n        || /BlackBerry/.test(navigator.userAgent)\r\n        || /(UC Browser |UCWEB)/.test(navigator.userAgent)\r\n        || isIOS()\r\n        || isMobileVR();\r\n}\r\n\r\nexport function isDesktop() {\r\n    return !isMobile();\r\n}\r\n\r\nconst oculusBrowserPattern = /OculusBrowser\\/(\\d+)\\.(\\d+)\\.(\\d+)/i;\r\nconst oculusMatch = navigator.userAgent.match(oculusBrowserPattern);\r\nexport const isOculusBrowser = !!oculusMatch;\r\nexport const oculusBrowserVersion: { major: number, minor: number, patch: number } = isOculusBrowser && {\r\n    major: parseFloat(oculusMatch[1]),\r\n    minor: parseFloat(oculusMatch[2]),\r\n    patch: parseFloat(oculusMatch[3])\r\n};\r\n\r\nexport const isOculusGo = isOculusBrowser && /pacific/i.test(navigator.userAgent);\r\nexport const isOculusQuest = isOculusBrowser && /quest/i.test(navigator.userAgent);\r\nexport const isOculusQuest2 = isOculusBrowser && /quest 2/i.test(navigator.userAgent);\r\nexport const isOculusQuest1 = isOculusBrowser && !isOculusQuest2;\r\n\r\nexport const isWorker = !(\"Document\" in globalThis);", "const FalseNorthing: number = 10000000;\r\nconst invF: number = 298.257223563;\r\nconst equatorialRadius: number = 6378137;\r\nconst pointScaleFactor: number = 0.9996;\r\nconst E0: number = 500000;\r\n\r\nconst flattening: number = 1 / invF;\r\nconst flatteningComp: number = 1 - flattening;\r\nconst n: number = flattening / (2 - flattening);\r\nconst A: number = (equatorialRadius / (1 + n)) * (1 + (n * n / 4) + (n * n * n * n / 64));\r\n\r\nconst e: number = Math.sqrt(1 - (flatteningComp * flatteningComp));\r\nconst esq: number = 1 - (flatteningComp * flatteningComp);\r\nconst e0sq: number = e * e / (1 - (e * e));\r\n\r\nconst alpha1: number = 1 - (esq * (0.25 + (esq * ((3 / 64) + (5 * esq / 256)))));\r\nconst alpha2: number = esq * ((3 / 8) + (esq * ((3 / 32) + (45 * esq / 1024))));\r\nconst alpha3: number = esq * esq * ((15 / 256) + (esq * 45 / 1024));\r\nconst alpha4: number = esq * esq * esq * (35 / 3072);\r\n\r\nconst beta: number[] = [\r\n    (n / 2) - (2 * n * n / 3) + (37 * n * n * n / 96),\r\n    (n * n / 48) + (n * n * n / 15),\r\n    17 * n * n * n / 480\r\n];\r\n\r\nconst delta: number[] = [\r\n    (2 * n) - (2 * n * n / 3),\r\n    (7 * n * n / 3) - (8 * n * n * n / 5),\r\n    56 * n * n * n / 15\r\n];\r\n\r\nexport const DatumWGS_84 = {\r\n    FalseNorthing,\r\n    equatorialRadius,\r\n    pointScaleFactor,\r\n    E0,\r\n\r\n    A,\r\n    flattening,\r\n    \r\n    e,\r\n    esq,\r\n    e0sq,\r\n\r\n    alpha1,\r\n    alpha2,\r\n    alpha3,\r\n    alpha4,\r\n\r\n    beta,\r\n    delta\r\n};", "const Tau = 2 * Math.PI;\r\n\r\nexport function angleClamp(v: number) {\r\n    return ((v % Tau) + Tau) % Tau;\r\n}\r\n", "import { arrayClear } from \"../collections/arrayClear\";\r\nimport type { IProgress } from \"./IProgress\";\r\n\r\nexport abstract class BaseProgress implements IProgress {\r\n    private readonly attached = new Array<IProgress>();\r\n    private soFar: number = null;\r\n    private total: number = null;\r\n    private msg: string = null;\r\n    private est: number = null;\r\n\r\n    report(soFar: number, total: number, msg?: string, est?: number): void {\r\n        this.soFar = soFar;\r\n        this.total = total;\r\n        this.msg = msg;\r\n        this.est = est;\r\n        for (const attach of this.attached) {\r\n            attach.report(soFar, total, msg, est);\r\n        }\r\n    }\r\n\r\n    attach(prog: IProgress): void {\r\n        this.attached.push(prog);\r\n        prog.report(this.soFar, this.total, this.msg, this.est);\r\n    }\r\n\r\n    end() {\r\n        this.report(1, 1, \"done\");\r\n        this.soFar = null;\r\n        this.total = null;\r\n        this.msg = null;\r\n        this.est = null;\r\n        arrayClear(this.attached);\r\n    }\r\n}", "import type { BaseParentProgressCallback } from \"./BaseParentProgressCallback\";\r\nimport { BaseProgress } from \"./BaseProgress\";\r\n\r\nexport class ChildProgressCallback extends BaseProgress {\r\n    constructor(private readonly i: number, private readonly prog: BaseParentProgressCallback) {\r\n        super();\r\n    }\r\n\r\n    override report(soFar: number, total: number, msg?: string, est?: number) {\r\n        super.report(soFar, total, msg, est);\r\n        this.prog.update(this.i, soFar, total, msg);\r\n    }\r\n}\r\n", "import { ChildProgressCallback } from \"./ChildProgressCallback\";\r\nimport type { IProgress } from \"./IProgress\";\r\n\r\nexport class BaseParentProgressCallback {\r\n    private weightTotal = 0;\r\n    private readonly start: number;\r\n\r\n    readonly subProgressCallbacks = new Array<IProgress>();\r\n    private readonly subProgressWeights = new Array<number>();\r\n    private readonly subProgressValues = new Array<number>();\r\n\r\n    constructor(private readonly prog: IProgress) {\r\n        this.start = performance.now();\r\n\r\n        for (let i = 0; i < this.subProgressWeights.length; ++i) {\r\n            this.subProgressValues[i] = 0;\r\n            this.subProgressCallbacks[i] = new ChildProgressCallback(i, this);\r\n        }\r\n    }\r\n\r\n    protected addSubProgress(weight?: number): IProgress {\r\n        weight = weight || 1;\r\n        this.weightTotal += weight;\r\n        this.subProgressWeights.push(weight);\r\n        this.subProgressValues.push(0);\r\n        const child = new ChildProgressCallback(this.subProgressCallbacks.length, this);\r\n        this.subProgressCallbacks.push(child);\r\n        return child;\r\n    }\r\n\r\n\r\n    update(i: number, subSoFar: number, subTotal: number, msg?: string) {\r\n        if (this.prog) {\r\n            this.subProgressValues[i] = subSoFar / subTotal;\r\n            let soFar = 0;\r\n            for (let j = 0; j < this.subProgressWeights.length; ++j) {\r\n                soFar += this.subProgressValues[j] * this.subProgressWeights[j];\r\n            }\r\n\r\n            const end = performance.now();\r\n            const delta = end - this.start;\r\n            const est = this.start - end + delta * this.weightTotal / soFar;\r\n            this.prog.report(soFar, this.weightTotal, msg, est);\r\n        }\r\n    };\r\n}\r\n", "import { isDefined, isFunction } from \"../typeChecks\";\r\n\r\nexport interface IProgress {\r\n    report(soFar: number, total: number, message?: string, est?: number): void;\r\n    attach(prog: IProgress): void;\r\n    end(): void;\r\n}\r\n\r\nexport function isProgressCallback(obj: any): obj is IProgress {\r\n    return isDefined(obj)\r\n        && isFunction(obj.report)\r\n        && isFunction(obj.attach)\r\n        && isFunction(obj.end);\r\n}", "import { BaseParentProgressCallback } from \"./BaseParentProgressCallback\";\r\nimport { IProgress } from \"./IProgress\";\r\n\r\nexport function progressPopper(progress: IProgress) {\r\n    return new PoppableParentProgressCallback(progress);\r\n}\r\n\r\nexport class PoppableParentProgressCallback extends BaseParentProgressCallback {\r\n    pop(weight?: number) {\r\n        return this.addSubProgress(weight);\r\n    }\r\n}\r\n", "import { TypedEvent, TypedEventBase } from \"../events/EventBase\";\r\nimport type { IProgress } from \"../progress/IProgress\";\r\nimport { isProgressCallback } from \"../progress/IProgress\";\r\nimport { assertNever, isArray, isDefined } from \"../typeChecks\";\r\nimport type { IDisposable } from \"../using\";\r\nimport type {\r\n    WorkerClientMethodCallMessage,\r\n    WorkerServerErrorMessage,\r\n    WorkerServerEventMessage,\r\n    WorkerServerMessages,\r\n    WorkerServerProgressMessage,\r\n    WorkerServerReturnMessage\r\n} from \"./WorkerMessages\";\r\n\r\ninterface WorkerInvocation {\r\n    onProgress: IProgress;\r\n    resolve: (value: any) => void;\r\n    reject: (reason?: any) => void;\r\n    methodName: string;\r\n}\r\n\r\nexport class WorkerClient<EventsT> extends TypedEventBase<EventsT> implements IDisposable {\r\n    static isSupported = \"Worker\" in globalThis;\r\n\r\n    private taskCounter = 0;\r\n    private invocations = new Map<number, WorkerInvocation>();\r\n\r\n    /**\r\n     * Creates a new pooled worker method executor.\r\n     * @param options\r\n     */\r\n    constructor(private worker: Worker) {\r\n        super();\r\n\r\n        if (!WorkerClient.isSupported) {\r\n            console.warn(\"Workers are not supported on this system.\");\r\n        }\r\n\r\n        this.worker.addEventListener(\"message\", (evt: MessageEvent<WorkerServerMessages>) => {\r\n            const data = evt.data;\r\n            switch (data.type) {\r\n                case \"event\":\r\n                    this.propogateEvent(data);\r\n                    break;\r\n                case \"progress\":\r\n                    this.progressReport(data);\r\n                    break;\r\n                case \"return\":\r\n                    this.methodReturned(data);\r\n                    break;\r\n                case \"error\":\r\n                    this.invocationError(data);\r\n                    break;\r\n                default:\r\n                    assertNever(data);\r\n            }\r\n        });\r\n    }\r\n\r\n    private postMessage(message: WorkerClientMethodCallMessage, transferables?: Transferable[]) {\r\n        if (message.type !== \"methodCall\") {\r\n            assertNever(message.type);\r\n        }\r\n\r\n        if (transferables) {\r\n            this.worker.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.worker.postMessage(message);\r\n        }\r\n    }\r\n\r\n    dispose() {\r\n        this.worker.terminate();\r\n    }\r\n\r\n    private propogateEvent(data: WorkerServerEventMessage) {\r\n        const evt = new TypedEvent(data.eventName);\r\n        this.dispatchEvent(Object.assign(evt, data.data));\r\n    }\r\n\r\n    private progressReport(data: WorkerServerProgressMessage) {\r\n        const invocation = this.invocations.get(data.taskID);\r\n        const { onProgress } = invocation;\r\n        if (onProgress) {\r\n            onProgress.report(data.soFar, data.total, data.msg, data.est);\r\n        }\r\n    }\r\n\r\n    private methodReturned(data: WorkerServerReturnMessage) {\r\n        const messageHandler = this.removeInvocation(data.taskID);\r\n        const { resolve } = messageHandler;\r\n        resolve(data.returnValue);\r\n    }\r\n\r\n    private invocationError(data: WorkerServerErrorMessage) {\r\n        const messageHandler = this.removeInvocation(data.taskID);\r\n        const { reject, methodName } = messageHandler;\r\n        reject(new Error(`${methodName} failed. Reason: ${data.errorMessage}`));\r\n    }\r\n\r\n    /**\r\n     * When the invocation has errored, we want to stop listening to the worker\r\n     * message channel so we don't eat up processing messages that have no chance\r\n     * ever pertaining to the invocation.\r\n     **/\r\n    private removeInvocation(taskID: number) {\r\n        const invocation = this.invocations.get(taskID);\r\n        this.invocations.delete(taskID);\r\n        return invocation;\r\n    }\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, params: any[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, params: any[], transferables: Transferable[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param parameters - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, parameters?: any[] | IProgress, transferables?: Transferable[] | IProgress, onProgress?: IProgress): Promise<T | undefined> {\r\n        if (!WorkerClient.isSupported) {\r\n            return Promise.reject(new Error(\"Workers are not supported on this system.\"));\r\n        }\r\n\r\n        // Normalize method parameters.\r\n        let params: any[] = null;\r\n        let tfers: Transferable[] = null;\r\n\r\n        if (isProgressCallback(parameters)) {\r\n            onProgress = parameters;\r\n            parameters = null;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isProgressCallback(transferables)\r\n            && !onProgress) {\r\n            onProgress = transferables;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isArray(parameters)) {\r\n            params = parameters;\r\n        }\r\n\r\n        if (isArray(transferables)) {\r\n            tfers = transferables;\r\n        }\r\n\r\n        // taskIDs help us keep track of return values.\r\n        const taskID = this.taskCounter++;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const invocation: WorkerInvocation = {\r\n                onProgress,\r\n                resolve,\r\n                reject,\r\n                methodName\r\n            };\r\n\r\n            this.invocations.set(taskID, invocation);\r\n\r\n            let message: WorkerClientMethodCallMessage = null;\r\n            if (isDefined(parameters)) {\r\n                message = {\r\n                    type: \"methodCall\",\r\n                    taskID,\r\n                    methodName,\r\n                    params\r\n                };\r\n            }\r\n            else {\r\n                message = {\r\n                    type: \"methodCall\",\r\n                    taskID,\r\n                    methodName\r\n                };\r\n            }\r\n\r\n            this.postMessage(message, tfers);\r\n        });\r\n    }\r\n}\r\n", "import { arrayClear } from \"../collections/arrayClear\";\r\nimport { TypedEventBase } from \"../events/EventBase\";\r\nimport type { IProgress } from \"../progress/IProgress\";\r\nimport { isProgressCallback } from \"../progress/IProgress\";\r\nimport { isArray, isDefined, isNullOrUndefined, isNumber } from \"../typeChecks\";\r\nimport type { IDisposable } from \"../using\";\r\nimport { WorkerClient } from \"./WorkerClient\";\r\nimport type { FullWorkerClientOptions } from \"./WorkerClientOptions\";\r\n\r\nexport type WorkerConstructorT<EventsT, WorkerClientT extends WorkerClient<EventsT>> = new (worker: Worker) => WorkerClientT;\r\n\r\nexport class WorkerPool<EventsT, WorkerClientT extends WorkerClient<EventsT>>\r\n    extends TypedEventBase<EventsT>\r\n    implements IDisposable {\r\n    static isSupported = \"Worker\" in globalThis;\r\n\r\n    private scriptPath: string;\r\n    private taskCounter: number;\r\n    protected readonly workers: WorkerClientT[];\r\n\r\n    /**\r\n     * Creates a new pooled worker method executor.\r\n     * @param options\r\n     */\r\n    constructor(options: FullWorkerClientOptions, WorkerClientClass: WorkerConstructorT<EventsT, WorkerClientT>) {\r\n        super();\r\n\r\n        this.scriptPath = options.scriptPath;\r\n\r\n        let workerPoolSize: number = -1;\r\n        const workersDef = options.workers;\r\n        let workers: Array<Worker> = null;\r\n        if (isNumber(workersDef)) {\r\n            workerPoolSize = workersDef;\r\n        }\r\n        else if (isDefined(workersDef)) {\r\n            this.taskCounter = workersDef.curTaskCounter;\r\n            workers = workersDef.workers;\r\n            workerPoolSize = workers.length;\r\n        }\r\n        else {\r\n            workerPoolSize = navigator.hardwareConcurrency || 4;\r\n        }\r\n\r\n        // Validate parameters\r\n        if (workerPoolSize < 1) {\r\n            throw new Error(\"Worker pool size must be a postive integer greater than 0\");\r\n        }\r\n\r\n        this.workers = new Array(workerPoolSize);\r\n\r\n        if (isNullOrUndefined(workers)) {\r\n            this.taskCounter = 0;\r\n            for (let i = 0; i < workerPoolSize; ++i) {\r\n                this.workers[i] = new WorkerClientClass(new Worker(this.scriptPath, { type: \"module\" }));\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < workerPoolSize; ++i) {\r\n                this.workers[i] = new WorkerClientClass(workers[i]);\r\n            }\r\n        }\r\n\r\n        for (const worker of this.workers) {\r\n            worker.addBubbler(this);\r\n        }\r\n    }\r\n\r\n    dispose() {\r\n        for (const worker of this.workers) {\r\n            worker.dispose();\r\n        }\r\n        arrayClear(this.workers);\r\n    }\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, params: any[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, params: any[], transferables: Transferable[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, params?: any[] | IProgress, transferables?: Transferable[] | IProgress, onProgress?: IProgress): Promise<T | undefined> {\r\n        if (!WorkerClient.isSupported) {\r\n            return Promise.reject(new Error(\"Workers are not supported on this system.\"));\r\n        }\r\n\r\n        // Normalize method parameters.\r\n        let parameters: any[] = null;\r\n        let tfers: Transferable[] = null;\r\n\r\n        if (isProgressCallback(params)) {\r\n            onProgress = params;\r\n            params = null;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isProgressCallback(transferables)\r\n            && !onProgress) {\r\n            onProgress = transferables;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isArray(params)) {\r\n            parameters = params;\r\n        }\r\n\r\n        if (isArray(transferables)) {\r\n            tfers = transferables;\r\n        }\r\n\r\n        const worker = this.nextWorker();\r\n\r\n        return worker.callMethod<T>(methodName, parameters, tfers, onProgress);\r\n    }\r\n\r\n    protected nextWorker() {\r\n        // taskIDs help us keep track of return values.\r\n        // The modulus selects them in a round-robin fashion.\r\n        const taskID = this.taskCounter++;\r\n        const workerID = taskID % this.workers.length;\r\n        return this.workers[workerID];\r\n    }\r\n}\r\n", "import { EventBase } from \"../events/EventBase\";\r\nimport { BaseProgress } from \"../progress/BaseProgress\";\r\nimport { isArray, isDefined } from \"../typeChecks\";\r\nimport { WorkerClientMethodCallMessage, WorkerServerErrorMessage, WorkerServerEventMessage, WorkerServerMessages, WorkerServerProgressMessage, WorkerServerReturnMessage } from \"./WorkerMessages\";\r\n\r\ntype workerServerMethod = (taskID: number, ...params: any[]) => Promise<void>;\r\n\r\ntype createTransferableCallback<T> = (returnValue: T) => Transferable[];\r\n\r\ntype Executor<T> = (...params: any[]) => Promise<T>;\r\n\r\ntype VoidExecutor = (...params: any[]) => void;\r\n\r\nclass WorkerServerProgress extends BaseProgress {\r\n    constructor(private readonly server: WorkerServer, private readonly taskID: number) {\r\n        super();\r\n    }\r\n\r\n\r\n    /**\r\n     * Report progress through long-running invocations. If your invocable\r\n     * functions don't report progress, this can be safely ignored.\r\n     * @param soFar - how much of the process we've gone through.\r\n     * @param total - the total amount we need to go through.\r\n     * @param msg - an optional message to include as part of the progress update.\r\n     * @param est - an optional estimate of how many milliseconds are left in the progress.\r\n     */\r\n    override report(soFar: number, total: number, msg?: string, est?: number): void {\r\n        const message: WorkerServerProgressMessage = {\r\n            type: \"progress\",\r\n            taskID: this.taskID,\r\n            soFar,\r\n            total,\r\n            msg,\r\n            est\r\n        };\r\n        this.server.postMessage(message);\r\n    }\r\n}\r\n\r\nexport class WorkerServer {\r\n    private methods = new Map<string, workerServerMethod>();\r\n\r\n    /**\r\n     * Creates a new worker thread method call listener.\r\n     * @param self - the worker scope in which to listen.\r\n     */\r\n    constructor(private self: DedicatedWorkerGlobalScope) {\r\n        this.self.addEventListener(\"message\", (evt: MessageEvent<WorkerClientMethodCallMessage>): void => {\r\n            const data = evt.data;\r\n            this.callMethod(data);\r\n        });\r\n    }\r\n\r\n    postMessage(message: WorkerServerMessages, transferables?: Transferable[]): void {\r\n        if (isDefined(transferables)) {\r\n            this.self.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.self.postMessage(message);\r\n        }\r\n    }\r\n\r\n    private callMethod(data: WorkerClientMethodCallMessage) {\r\n        const method = this.methods.get(data.methodName);\r\n        if (method) {\r\n            try {\r\n                if (isArray(data.params)) {\r\n                    method(data.taskID, ...data.params);\r\n                }\r\n                else if (isDefined(data.params)) {\r\n                    method(data.taskID, data.params);\r\n                }\r\n                else {\r\n                    method(data.taskID);\r\n                }\r\n            }\r\n            catch (exp) {\r\n                this.onError(data.taskID, `method invocation error: ${data.methodName}(${exp.message || exp})`);\r\n            }\r\n        }\r\n        else {\r\n            this.onError(data.taskID, `method not found: ${data.methodName}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Report an error back to the calling thread.\r\n     * @param taskID - the invocation ID of the method that errored.\r\n     * @param errorMessage - what happened?\r\n     */\r\n    private onError(taskID: number, errorMessage: string): void {\r\n        const message: WorkerServerErrorMessage = {\r\n            type: \"error\",\r\n            taskID,\r\n            errorMessage\r\n        };\r\n        this.postMessage(message);\r\n    }\r\n\r\n    /**\r\n     * Return back to the client.\r\n     * @param taskID - the invocation ID of the method that is returning.\r\n     * @param returnValue - the (optional) value to return.\r\n     * @param transferReturnValue - a mapping function to extract any Transferable objects from the return value.\r\n     */\r\n    private onReturn<T>(taskID: number, returnValue: T, transferReturnValue: createTransferableCallback<T>): void {\r\n        let message: WorkerServerReturnMessage = null;\r\n        if (returnValue === undefined) {\r\n            message = {\r\n                type: \"return\",\r\n                taskID\r\n            };\r\n        }\r\n        else {\r\n            message = {\r\n                type: \"return\",\r\n                taskID,\r\n                returnValue\r\n            };\r\n        }\r\n\r\n        if (isDefined(transferReturnValue)) {\r\n            const transferables = transferReturnValue(returnValue);\r\n            this.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.postMessage(message);\r\n        }\r\n    }\r\n\r\n    private onEvent<T>(eventName: string, evt: Event, makePayload?: (evt: Event) => T, transferReturnValue?: createTransferableCallback<T>): void {\r\n        let message: WorkerServerEventMessage = null;\r\n        if (isDefined(makePayload)) {\r\n            message = {\r\n                type: \"event\",\r\n                eventName,\r\n                data: makePayload(evt)\r\n            };\r\n        }\r\n        else {\r\n            message = {\r\n                type: \"event\",\r\n                eventName\r\n            };\r\n        }\r\n\r\n        if (message.data !== undefined\r\n            && isDefined(transferReturnValue)) {\r\n            const transferables = transferReturnValue(message.data);\r\n            this.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.postMessage(message);\r\n        }\r\n    }\r\n\r\n    private addMethodInternal<T>(methodName: string, asyncFunc: Function, transferReturnValue?: createTransferableCallback<T>) {\r\n        if (this.methods.has(methodName)) {\r\n            throw new Error(`${methodName} method has already been mapped.`);\r\n        }\r\n\r\n        this.methods.set(methodName, async (taskID: number, ...params: any[]) => {\r\n            const onProgress = new WorkerServerProgress(this, taskID);\r\n\r\n            try {\r\n                // Even functions returning void and functions returning bare, unPromised values, can be awaited.\r\n                // This creates a convenient fallback where we don't have to consider the exact return type of the function.\r\n                const returnValue = await asyncFunc(...params, onProgress);\r\n                this.onReturn(taskID, returnValue, transferReturnValue);\r\n            }\r\n            catch (exp) {\r\n                console.error(exp);\r\n                this.onError(taskID, exp.message || exp);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Registers a function call for cross-thread invocation.\r\n     * @param methodName - the name of the function to use during invocations.\r\n     * @param asyncFunc - the function to execute when the method is invoked.\r\n     * @param transferReturnValue - an (optional) function that reports on which values in the `returnValue` should be transfered instead of copied.\r\n     */\r\n    addFunction<T>(methodName: string, asyncFunc: Executor<T>, transferReturnValue?: createTransferableCallback<T>) {\r\n        this.addMethodInternal<T>(methodName, asyncFunc, transferReturnValue);\r\n    }\r\n\r\n    /**\r\n     * Registers a function call for cross-thread invocation.\r\n     * @param methodName - the name of the function to use during invocations.\r\n     * @param asyncFunc - the function to execute when the method is invoked.\r\n     */\r\n    addVoidFunction(methodName: string, asyncFunc: VoidExecutor) {\r\n        this.addMethodInternal(methodName, asyncFunc);\r\n    }\r\n\r\n    /**\r\n     * Registers a class method call for cross-thread invocation.\r\n     * @param methodName - the name of the method to use during invocations.\r\n     * @param obj - the object on which to find the method.\r\n     * @param transferReturnValue - an (optional) function that reports on which values in the `returnValue` should be transfered instead of copied.\r\n     */\r\n    addMethod<\r\n        ClassT,\r\n        ReturnT,\r\n        MethodNameT extends keyof ClassT & string,\r\n        MethodT extends ClassT[MethodNameT]>(\r\n            methodName: MethodNameT,\r\n            obj: ClassT,\r\n            method: MethodT & Executor<ReturnT>,\r\n            transferReturnValue?: createTransferableCallback<ReturnT>): void {\r\n        this.addFunction(methodName, method.bind(obj), transferReturnValue);\r\n    }\r\n\r\n\r\n    /**\r\n     * Registers a class method call for cross-thread invocation.\r\n     * @param methodName - the name of the method to use during invocations.\r\n     * @param obj - the object on which to find the method.\r\n     */\r\n    addVoidMethod<\r\n        ClassT,\r\n        MethodNameT extends keyof ClassT & string,\r\n        MethodT extends ClassT[MethodNameT]>(\r\n            methodName: MethodNameT,\r\n            obj: ClassT,\r\n            method: MethodT & VoidExecutor): void {\r\n        this.addVoidFunction(methodName, method.bind(obj));\r\n    }\r\n\r\n\r\n    addEvent<U extends EventBase, T>(object: U, type: string, makePayload?: (evt: Event) => T, transferReturnValue?: createTransferableCallback<T>): void {\r\n        object.addEventListener(type, (evt: Event) =>\r\n            this.onEvent(type, evt, makePayload, transferReturnValue));\r\n    }\r\n}", "\uFEFFimport { IResponse } from \"./IFetcher\";\r\n\r\nexport class ResponseTranslator {\r\n    protected async translateResponse<T, U>(responseTask: Promise<IResponse<T>>, translate: (v: T) => U | Promise<U>): Promise<IResponse<U>> {\r\n        const {\r\n            status, content, contentType, contentLength, fileName, headers, date\r\n        } = await responseTask;\r\n\r\n        return {\r\n            status,\r\n            content: await translate(content),\r\n            contentType,\r\n            contentLength,\r\n            fileName,\r\n            headers,\r\n            date\r\n        };\r\n    }\r\n}\r\n", "import type { IProgress } from \"juniper-tslib\";\r\nimport { isDefined, isString, isXHRBodyInit, mapJoin, progressPopper } from \"juniper-tslib\";\r\nimport type { IFetchingService, IRequest, IRequestWithBody, IResponse } from \"./IFetcher\";\r\nimport { ResponseTranslator } from \"./ResponseTranslator\";\r\n\r\nfunction trackProgress(name: string, xhr: XMLHttpRequest, target: (XMLHttpRequest | XMLHttpRequestUpload), onProgress: IProgress, skipLoading: boolean, prevTask?: Promise<void>): Promise<void> {\r\n    return new Promise((resolve: () => void, reject: (msg: string) => void) => {\r\n        let prevDone = !prevTask;\r\n        if (prevTask) {\r\n            prevTask.then(() => prevDone = true);\r\n        }\r\n\r\n        let done = false;\r\n        let loaded = skipLoading;\r\n        function maybeResolve() {\r\n            if (loaded && done) {\r\n                resolve();\r\n            }\r\n        }\r\n\r\n        function onError(msg: string) {\r\n            return () => {\r\n                if (prevDone) {\r\n                    reject(`${msg} (${xhr.status})`);\r\n                }\r\n            }\r\n        }\r\n\r\n        target.addEventListener(\"loadstart\", () => {\r\n            if (prevDone && !done && onProgress) {\r\n                onProgress.report(0, 1, name);\r\n            }\r\n        });\r\n\r\n        target.addEventListener(\"progress\", (ev: Event) => {\r\n            if (prevDone && !done) {\r\n                const evt = ev as ProgressEvent<XMLHttpRequestEventTarget>;\r\n                if (onProgress) {\r\n                    onProgress.report(evt.loaded, Math.max(evt.loaded, evt.total), name);\r\n                }\r\n                if (evt.loaded === evt.total) {\r\n                    loaded = true;\r\n                    maybeResolve();\r\n                }\r\n            }\r\n        });\r\n\r\n        target.addEventListener(\"load\", () => {\r\n            if (prevDone && !done) {\r\n                if (onProgress) {\r\n                    onProgress.report(1, 1, name);\r\n                }\r\n                done = true;\r\n                maybeResolve();\r\n            }\r\n        });\r\n\r\n        target.addEventListener(\"error\", onError(\"error\"));\r\n        target.addEventListener(\"abort\", onError(\"abort\"));\r\n        target.addEventListener(\"timeout\", onError(\"timeout\"));\r\n    });\r\n}\r\n\r\nfunction sendRequest(xhr: XMLHttpRequest, xhrType: XMLHttpRequestResponseType, method: string, path: string, timeout: number, headers: Map<string, string>, body?: BodyInit): void {\r\n    xhr.open(method, path);\r\n    xhr.responseType = xhrType;\r\n    xhr.timeout = timeout;\r\n    if (headers) {\r\n        for (const [key, value] of headers) {\r\n            xhr.setRequestHeader(key, value);\r\n        }\r\n    }\r\n\r\n    if (isDefined(body)) {\r\n        xhr.send(body);\r\n    }\r\n    else {\r\n        xhr.send();\r\n    }\r\n}\r\n\r\nfunction readResponseHeader<T>(headers: Map<string, string>, key: string, translate: (value: string) => T): T {\r\n    if (!headers.has(key)) {\r\n        return null;\r\n    }\r\n\r\n    const value = headers.get(key);\r\n    try {\r\n        const translated = translate(value);\r\n        headers.delete(key);\r\n        return translated;\r\n    }\r\n    catch (exp) {\r\n        console.warn(key, exp);\r\n    }\r\n    return null;\r\n}\r\n\r\nconst FILE_NAME_PATTERN = /filename=\\\"(.+)\\\"(;|$)/;\r\nfunction readResponse<T>(xhr: XMLHttpRequest) {\r\n    const parts = xhr\r\n        .getAllResponseHeaders()\r\n        .split(/[\\r\\n]+/)\r\n        .map<[string, string]>(line => {\r\n            const parts = line.split(\": \");\r\n            const key = parts.shift();\r\n            const value = parts.join(\": \");\r\n            return [key, value];\r\n        })\r\n        .filter(kv => kv[0].length > 0);\r\n\r\n    const headers = new Map<string, string>(parts);\r\n\r\n    const response: IResponse<T> = {\r\n        status: xhr.status,\r\n        content: xhr.response as T,\r\n        contentType: readResponseHeader(headers, \"content-type\", v => v),\r\n        contentLength: readResponseHeader(headers, \"content-length\", parseFloat),\r\n        fileName: readResponseHeader(headers, \"content-disposition\", v => {\r\n            if (isDefined(v)) {\r\n                const match = v.match(FILE_NAME_PATTERN);\r\n                if (isDefined(match)) {\r\n                    return match[1];\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }),\r\n        date: readResponseHeader(headers, \"date\", v => new Date(v)),\r\n        headers\r\n    };\r\n\r\n    return response;\r\n}\r\n\r\nexport class FetchingServiceImpl\r\n    extends ResponseTranslator\r\n    implements IFetchingService {\r\n\r\n    private readonly defaultPostHeaders = new Map<string, string>();\r\n\r\n    setRequestVerificationToken(value: string): void {\r\n        this.defaultPostHeaders.set(\"RequestVerificationToken\", value);\r\n    }\r\n\r\n    private async headOrGetXHR<T>(method: string, xhrType: XMLHttpRequestResponseType, request: IRequest, progress: IProgress): Promise<IResponse<T>> {\r\n        const xhr = new XMLHttpRequest();\r\n        const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, progress, true);\r\n\r\n        sendRequest(xhr, xhrType, method, request.path, request.timeout, request.headers);\r\n\r\n        await download;\r\n        return readResponse(xhr);\r\n    }\r\n\r\n    private getXHR<T>(xhrType: XMLHttpRequestResponseType, request: IRequest, progress: IProgress): Promise<IResponse<T>> {\r\n        return this.headOrGetXHR(\"GET\", xhrType, request, progress);\r\n    }\r\n\r\n    head(request: IRequest): Promise<IResponse<void>> {\r\n        return this.headOrGetXHR(\"HEAD\", \"\", request, null);\r\n    }\r\n\r\n    private async postXHR<T>(xhrType: XMLHttpRequestResponseType, request: IRequestWithBody, prog: IProgress): Promise<IResponse<T>> {\r\n\r\n        let body: BodyInit = null;\r\n\r\n        \r\n        const headers = mapJoin(new Map<string, string>(), this.defaultPostHeaders, request.headers);\r\n\r\n        if (request.body instanceof FormData\r\n            && isDefined(headers)) {\r\n            const toDelete = new Array<string>();\r\n            for (const key of headers.keys()) {\r\n                if (key.toLowerCase() === \"content-type\") {\r\n                    toDelete.push(key);\r\n                }\r\n            }\r\n            for (const key of toDelete) {\r\n                headers.delete(key);\r\n            }\r\n        }\r\n\r\n        if (isXHRBodyInit(request.body) && !isString(request.body)) {\r\n            body = request.body;\r\n        }\r\n        else if (isDefined(request.body)) {\r\n            body = JSON.stringify(request.body);\r\n        }\r\n\r\n        const progs = progressPopper(prog);\r\n        const xhr = new XMLHttpRequest();        \r\n        const upload = isDefined(body)\r\n            ? trackProgress(\"uploading\", xhr, xhr.upload, progs.pop(), false)\r\n            : Promise.resolve();\r\n        const download = trackProgress(\"saving\", xhr, xhr, progs.pop(), true, upload);\r\n\r\n        sendRequest(xhr, xhrType, \"POST\", request.path, request.timeout, headers, body);\r\n\r\n        await upload;\r\n        await download;\r\n        return readResponse(xhr);\r\n    }\r\n\r\n    getBlob(request: IRequest, progress: IProgress): Promise<IResponse<Blob>> {\r\n        return this.getXHR<Blob>(\"blob\", request, progress);\r\n    }\r\n\r\n    postObjectForBlob(request: IRequestWithBody, progress: IProgress): Promise<IResponse<Blob>> {\r\n        return this.postXHR<Blob>(\"blob\", request, progress);\r\n    }\r\n\r\n    getBuffer(request: IRequest, progress: IProgress): Promise<IResponse<ArrayBuffer>> {\r\n        return this.getXHR<ArrayBuffer>(\"arraybuffer\", request, progress);\r\n    }\r\n\r\n    postObjectForBuffer(request: IRequestWithBody, progress: IProgress): Promise<IResponse<ArrayBuffer>> {\r\n        return this.postXHR<ArrayBuffer>(\"arraybuffer\", request, progress);\r\n    }\r\n\r\n    getText(request: IRequest, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.getXHR<string>(\"text\", request, progress);\r\n    }\r\n\r\n    postObjectForText(request: IRequestWithBody, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.postXHR<string>(\"text\", request, progress);\r\n    }\r\n\r\n    async getObject<T>(request: IRequest, progress: IProgress): Promise<T> {\r\n        const response = await this.getXHR<T>(\"json\", request, progress);\r\n        return response.content;\r\n    }\r\n\r\n    async postObjectForObject<T>(request: IRequestWithBody, progress: IProgress): Promise<T> {\r\n        const response = await this.postXHR<T>(\"json\", request, progress);\r\n        return response.content;\r\n    }\r\n\r\n    postObject(request: IRequestWithBody, progress: IProgress): Promise<IResponse<void>> {\r\n        return this.postXHR<void>(\"\", request, progress);\r\n    }\r\n\r\n    getFile(request: IRequest, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.translateResponse(\r\n            this.getBlob(request, progress),\r\n            URL.createObjectURL);\r\n    }\r\n\r\n    postObjectForFile(request: IRequestWithBody, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.translateResponse(\r\n            this.postObjectForBlob(request, progress),\r\n            URL.createObjectURL);\r\n    }\r\n\r\n    getXml(request: IRequest, progress: IProgress): Promise<IResponse<HTMLElement>> {\r\n        return this.translateResponse(\r\n            this.getXHR<Document>(\"document\", request, progress),\r\n            doc => doc.documentElement);\r\n    }\r\n\r\n    postObjectForXml(request: IRequestWithBody, progress: IProgress): Promise<IResponse<HTMLElement>> {\r\n        return this.translateResponse(\r\n            this.postXHR<Document>(\"document\", request, progress),\r\n            doc => doc.documentElement);\r\n    }\r\n\r\n    getImageBitmap(request: IRequest, progress: IProgress): Promise<IResponse<ImageBitmap>> {\r\n        return this.translateResponse(\r\n            this.getBlob(request, progress),\r\n            createImageBitmap)\r\n    }\r\n\r\n    async postObjectForImageBitmap(request: IRequestWithBody, progress: IProgress): Promise<IResponse<ImageBitmap>> {\r\n        return this.translateResponse(\r\n            this.postObjectForBlob(request, progress),\r\n            createImageBitmap);\r\n    }\r\n}\r\n", "import { FetchingServiceImpl } from \"juniper-fetcher-base/FetchingServiceImpl\";\r\nimport type { IFetchingService, IResponse } from \"juniper-fetcher-base/IFetcher\";\r\nimport { WorkerServer } from \"juniper-tslib\";\r\n\r\nexport class FetchingServiceServer extends WorkerServer {\r\n    constructor(self: DedicatedWorkerGlobalScope) {\r\n        super(self);\r\n\r\n        const fetcher = new FetchingServiceImpl();\r\n        addFetcherMethods(this, fetcher);\r\n    }\r\n}\r\n\r\nfunction getContent<T extends Transferable>(response: IResponse<T>): Array<Transferable> {\r\n    return [response.content];\r\n}\r\n\r\nexport function addFetcherMethods(server: WorkerServer, fetcher: IFetchingService) {\r\n    server.addVoidMethod(\"setRequestVerificationToken\", fetcher, fetcher.setRequestVerificationToken);\r\n\r\n    server.addMethod(\"getBuffer\", fetcher, fetcher.getBuffer, getContent);\r\n    server.addMethod(\"postObjectForBuffer\", fetcher, fetcher.postObjectForBuffer, getContent);\r\n    server.addMethod(\"getImageBitmap\", fetcher, fetcher.getImageBitmap, getContent);\r\n    server.addMethod(\"postObjectForImageBitmap\", fetcher, fetcher.postObjectForImageBitmap, getContent);\r\n\r\n    server.addMethod(\"getObject\", fetcher, fetcher.getObject);\r\n    server.addMethod(\"getFile\", fetcher, fetcher.getFile);\r\n    server.addMethod(\"getText\", fetcher, fetcher.getText);\r\n    server.addMethod(\"postObject\", fetcher, fetcher.postObject);\r\n    server.addMethod(\"postObjectForObject\", fetcher, fetcher.postObjectForObject);\r\n    server.addMethod(\"postObjectForFile\", fetcher, fetcher.postObjectForFile);\r\n    server.addMethod(\"postObjectForText\", fetcher, fetcher.postObjectForText);\r\n\r\n    server.addMethod(\"head\", fetcher, fetcher.head);\r\n}\r\n", "import { FetchingServiceServer } from \"./FetchingServiceServer\";\r\n(globalThis as any).server = new FetchingServiceServer((globalThis as any) as DedicatedWorkerGlobalScope);"],
  "mappings": "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",
  "names": []
}
