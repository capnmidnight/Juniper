{
  "version": 3,
  "sources": ["../../tslib/typeChecks.ts", "../../tslib/collections/arrayRemoveAt.ts", "../../tslib/collections/arrayClear.ts", "../../tslib/events/EventBase.ts", "../../tslib/collections/mapJoin.ts", "../../tslib/flags.ts", "../../tslib/gis/Datum.ts", "../../tslib/math/angleClamp.ts", "../../tslib/progress/BaseProgress.ts", "../../tslib/progress/ChildProgressCallback.ts", "../../tslib/progress/BaseParentProgressCallback.ts", "../../tslib/progress/IProgress.ts", "../../tslib/progress/progressPopper.ts", "../../tslib/workers/WorkerClient.ts", "../../tslib/workers/WorkerPool.ts", "../../tslib/workers/WorkerServer.ts", "../../fetcher-base/ResponseTranslator.ts", "../../fetcher-base/FetchingServiceImpl.ts", "../src/FetchingServiceServer.ts", "../src/index.ts"],
  "sourcesContent": ["function t(o: any, s: string, c: Function) {\r\n    return typeof o === s\r\n        || o instanceof c;\r\n}\r\n\r\nexport function isFunction(obj: any): obj is Function {\r\n    return t(obj, \"function\", Function);\r\n}\r\n\r\nexport function isString(obj: any): obj is string {\r\n    return t(obj, \"string\", String);\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n    return t(obj, \"boolean\", Boolean);\r\n}\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n    return t(obj, \"number\", Number);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is not the special NaN value.\r\n */\r\nexport function isGoodNumber(obj: any): obj is number {\r\n    return isNumber(obj)\r\n        && !Number.isNaN(obj);\r\n}\r\n\r\nexport function isObject(obj: any): obj is object {\r\n    return isDefined(obj)\r\n        && t(obj, \"object\", Object);\r\n}\r\n\r\nexport function isPromise<T>(obj: any): obj is Promise<T> {\r\n    return obj instanceof Promise;\r\n}\r\n\r\nexport function isDate(obj: any): obj is Date {\r\n    return obj instanceof Date;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n    return obj instanceof Array;\r\n}\r\n\r\nexport function assertNever(x: never, msg?: string): never {\r\n    throw new Error((msg || \"Unexpected object: \") + x);\r\n}\r\n\r\nexport function isNullOrUndefined<T>(obj: T | null | undefined): obj is null | undefined {\r\n    return obj === null\r\n        || obj === undefined;\r\n}\r\n\r\nexport function isDefined<T>(obj: T | null | undefined): obj is T {\r\n    return !isNullOrUndefined(obj);\r\n}\r\n\r\nexport function isEventListener(obj: EventListenerOrEventListenerObject): obj is EventListener {\r\n    return isFunction(obj);\r\n}\r\n\r\nexport function isEventListenerObject(obj: EventListenerOrEventListenerObject): obj is EventListenerObject {\r\n    return !isEventListener(obj);\r\n}\r\n\r\nexport function isArrayBufferView(obj: any): obj is ArrayBufferView {\r\n    return obj instanceof Uint8Array\r\n        || obj instanceof Uint8ClampedArray\r\n        || obj instanceof Int8Array\r\n        || obj instanceof Uint16Array\r\n        || obj instanceof Int16Array\r\n        || obj instanceof Uint32Array\r\n        || obj instanceof Int32Array\r\n        || obj instanceof Float32Array\r\n        || obj instanceof Float64Array\r\n        || \"BigUint64Array\" in globalThis && obj instanceof globalThis[\"BigUint64Array\"]\r\n        || \"BigInt64Array\" in globalThis && obj instanceof globalThis[\"BigInt64Array\"];\r\n}\r\n\r\nexport function isHTMLElement(obj: any): obj is HTMLElement {\r\n    return obj instanceof HTMLElement;\r\n}\r\n\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\nexport function isXHRBodyInit(obj: any): obj is BodyInit {\r\n    return isString(obj)\r\n        || isArrayBufferView(obj)\r\n        || obj instanceof Blob\r\n        || obj instanceof FormData\r\n        || isArrayBuffer(obj)\r\n        || obj instanceof ReadableStream\r\n        || \"Document\" in globalThis && obj instanceof Document;\r\n}", "/**\r\n * Removes an item at the given index from an array.\r\n */\r\nexport function arrayRemoveAt<T>(arr: T[], idx: number) {\r\n    return arr.splice(idx, 1)[0];\r\n}", "/**\r\n * Empties out an array, returning the items that were in the array.\r\n * \r\n * @param arr the array to empty\r\n */\r\nexport function arrayClear<T>(arr: T[]) {\r\n    return arr.splice(0);\r\n}", "import { arrayClear } from \"../collections/arrayClear\";\r\nimport { arrayRemoveAt } from \"../collections/arrayRemoveAt\";\r\nimport { isBoolean, isDefined, isFunction, isNullOrUndefined } from \"../typeChecks\";\r\n\r\nconst allListeners = new WeakMap<EventBase, Map<string, Function[]>>();\r\n\r\nexport class EventBase implements EventTarget {\r\n    private readonly listeners = new Map<string, Function[]>();\r\n    private readonly listenerOptions = new Map<Function, boolean | AddEventListenerOptions>();\r\n\r\n    constructor() {\r\n        allListeners.set(this, this.listeners);\r\n    }\r\n\r\n    addEventListener(type: string, callback: (evt: Event) => any, options?: boolean | AddEventListenerOptions): void {\r\n        if (isFunction(callback)) {\r\n            let listeners = this.listeners.get(type);\r\n            if (!listeners) {\r\n                listeners = new Array<Function>();\r\n                this.listeners.set(type, listeners);\r\n            }\r\n\r\n            if (!listeners.find(c => c === callback)) {\r\n                listeners.push(callback);\r\n\r\n                if (options) {\r\n                    this.listenerOptions.set(callback, options);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (evt: Event) => any) {\r\n        if (isFunction(callback)) {\r\n            const listeners = this.listeners.get(type);\r\n            if (listeners) {\r\n                this.removeListener(listeners, callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeListener(listeners: Function[], callback: Function) {\r\n        const idx = listeners.findIndex(c => c === callback);\r\n        if (idx >= 0) {\r\n            arrayRemoveAt(listeners, idx);\r\n            if (this.listenerOptions.has(callback)) {\r\n                this.listenerOptions.delete(callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(evt: Event): boolean {\r\n        const listeners = this.listeners.get(evt.type);\r\n        if (listeners) {\r\n            for (const callback of listeners) {\r\n                const options = this.listenerOptions.get(callback);\r\n                if (isDefined(options)\r\n                    && !isBoolean(options)\r\n                    && options.once) {\r\n                    this.removeListener(listeners, callback);\r\n                }\r\n\r\n                callback.call(this, evt);\r\n            }\r\n        }\r\n        return !evt.defaultPrevented;\r\n    }\r\n}\r\n\r\nexport class TypedEvent<T extends string> extends Event {\r\n\r\n    override get type(): T {\r\n        return super.type as T;\r\n    }\r\n\r\n    constructor(type: T) {\r\n        super(type);\r\n    }\r\n}\r\n\r\nexport class TypedEventBase<EventsT> extends EventBase {\r\n    private readonly bubblers = new Set<TypedEventBase<EventsT>>();\r\n    private readonly scopes = new WeakMap<object, Array<[any, any]>>();\r\n\r\n    addBubbler(bubbler: TypedEventBase<EventsT>) {\r\n        this.bubblers.add(bubbler);\r\n    }\r\n\r\n    removeBubbler(bubbler: TypedEventBase<EventsT>) {\r\n        this.bubblers.delete(bubbler);\r\n    }\r\n\r\n    override addEventListener<K extends keyof EventsT & string>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any, options?: boolean | AddEventListenerOptions): void {\r\n        super.addEventListener(type, callback as any, options);\r\n    }\r\n\r\n    override removeEventListener<K extends keyof EventsT & string>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any) {\r\n        super.removeEventListener(type, callback as any);\r\n    }\r\n\r\n    addScopedEventListener<K extends keyof EventsT & string>(scope: object, type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any, options?: boolean | AddEventListenerOptions): void {\r\n        if (!this.scopes.has(scope)) {\r\n            this.scopes.set(scope, []);\r\n        }\r\n        this.scopes.get(scope).push([type, callback]);\r\n        this.addEventListener(type, callback as any, options);\r\n    }\r\n\r\n    removeScope<K extends keyof EventsT & string>(scope: object) {\r\n        const listeners = this.scopes.get(scope);\r\n        if (listeners) {\r\n            this.scopes.delete(scope);\r\n            for (const [type, listener] of listeners) {\r\n                this.removeEventListener(type as K, listener);\r\n            }\r\n        }\r\n    }\r\n\r\n    clearEventListeners<K extends keyof EventsT & string>(type?: K) {\r\n        const listeners = allListeners.get(this);\r\n        for (const [evtName, handlers] of listeners) {\r\n            if (isNullOrUndefined(type) || type === evtName) {\r\n                arrayClear(handlers);\r\n                listeners.delete(evtName);\r\n            }\r\n        }\r\n    }\r\n\r\n    override dispatchEvent<T extends Event>(evt: T): boolean {\r\n        if (!super.dispatchEvent(evt)) {\r\n            return false;\r\n        }\r\n\r\n        for (const bubbler of this.bubblers) {\r\n            if (!bubbler.dispatchEvent(evt)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}", "import { isDefined } from \"../typeChecks\";\r\n\r\nexport function mapJoin<KeyT, ValueT>(dest: Map<KeyT, ValueT>, ...sources: Map<KeyT, ValueT>[]): Map<KeyT, ValueT> {\r\n    for (const source of sources) {\r\n        if (isDefined(source)) {\r\n            for (const [key, value] of source) {\r\n                dest.set(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n", "export function isChrome() {\r\n    return \"chrome\" in globalThis && !navigator.userAgent.match(\"CriOS\");\r\n}\r\n\r\nexport function isFirefox() {\r\n    return \"InstallTrigger\" in globalThis;\r\n}\r\n\r\nexport function isSafari() {\r\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n}\r\n\r\nexport function isMacOS() {\r\n    return /^mac/i.test(navigator.platform);\r\n}\r\n\r\nexport function isIOS() {\r\n    return /iP(ad|hone|od)/.test(navigator.platform)\r\n        || /Macintosh(.*?) FxiOS(.*?)\\//.test(navigator.platform)\r\n        || isMacOS()\r\n            && \"maxTouchPoints\" in navigator\r\n            && (navigator as any).maxTouchPoints > 2;\r\n}\r\n\r\nexport function isApple() {\r\n    return isIOS()\r\n        || isMacOS();\r\n}\r\n\r\nexport function isMobileVR() {\r\n    return /Mobile VR/.test(navigator.userAgent)\r\n        || isOculusBrowser;\r\n}\r\n\r\nexport function hasWebXR() {\r\n    return \"xr\" in navigator\r\n        && \"isSessionSupported\" in (navigator as any).xr;\r\n}\r\n\r\nexport function hasWebVR() {\r\n    return \"getVRDisplays\" in navigator;\r\n}\r\n\r\nexport function hasVR() {\r\n    return hasWebXR() || hasWebVR();\r\n}\r\n\r\nexport function isMobile() {\r\n    return /Android/.test(navigator.userAgent)\r\n        || /BlackBerry/.test(navigator.userAgent)\r\n        || /(UC Browser |UCWEB)/.test(navigator.userAgent)\r\n        || isIOS()\r\n        || isMobileVR();\r\n}\r\n\r\nexport function isDesktop() {\r\n    return !isMobile();\r\n}\r\n\r\nconst oculusBrowserPattern = /OculusBrowser\\/(\\d+)\\.(\\d+)\\.(\\d+)/i;\r\nconst oculusMatch = navigator.userAgent.match(oculusBrowserPattern);\r\nexport const isOculusBrowser = !!oculusMatch;\r\nexport const oculusBrowserVersion: { major: number, minor: number, patch: number } = isOculusBrowser && {\r\n    major: parseFloat(oculusMatch[1]),\r\n    minor: parseFloat(oculusMatch[2]),\r\n    patch: parseFloat(oculusMatch[3])\r\n};\r\n\r\nexport const isOculusGo = isOculusBrowser && /pacific/i.test(navigator.userAgent);\r\nexport const isOculusQuest = isOculusBrowser && /quest/i.test(navigator.userAgent);\r\nexport const isOculusQuest2 = isOculusBrowser && /quest 2/i.test(navigator.userAgent);\r\nexport const isOculusQuest1 = isOculusBrowser && !isOculusQuest2;\r\n\r\nexport const isWorker = !(\"Document\" in globalThis);", "const FalseNorthing: number = 10000000;\r\nconst invF: number = 298.257223563;\r\nconst equatorialRadius: number = 6378137;\r\nconst pointScaleFactor: number = 0.9996;\r\nconst E0: number = 500000;\r\n\r\nconst flattening: number = 1 / invF;\r\nconst flatteningComp: number = 1 - flattening;\r\nconst n: number = flattening / (2 - flattening);\r\nconst A: number = (equatorialRadius / (1 + n)) * (1 + (n * n / 4) + (n * n * n * n / 64));\r\n\r\nconst e: number = Math.sqrt(1 - (flatteningComp * flatteningComp));\r\nconst esq: number = 1 - (flatteningComp * flatteningComp);\r\nconst e0sq: number = e * e / (1 - (e * e));\r\n\r\nconst alpha1: number = 1 - (esq * (0.25 + (esq * ((3 / 64) + (5 * esq / 256)))));\r\nconst alpha2: number = esq * ((3 / 8) + (esq * ((3 / 32) + (45 * esq / 1024))));\r\nconst alpha3: number = esq * esq * ((15 / 256) + (esq * 45 / 1024));\r\nconst alpha4: number = esq * esq * esq * (35 / 3072);\r\n\r\nconst beta: number[] = [\r\n    (n / 2) - (2 * n * n / 3) + (37 * n * n * n / 96),\r\n    (n * n / 48) + (n * n * n / 15),\r\n    17 * n * n * n / 480\r\n];\r\n\r\nconst delta: number[] = [\r\n    (2 * n) - (2 * n * n / 3),\r\n    (7 * n * n / 3) - (8 * n * n * n / 5),\r\n    56 * n * n * n / 15\r\n];\r\n\r\nexport const DatumWGS_84 = {\r\n    FalseNorthing,\r\n    equatorialRadius,\r\n    pointScaleFactor,\r\n    E0,\r\n\r\n    A,\r\n    flattening,\r\n    \r\n    e,\r\n    esq,\r\n    e0sq,\r\n\r\n    alpha1,\r\n    alpha2,\r\n    alpha3,\r\n    alpha4,\r\n\r\n    beta,\r\n    delta\r\n};", "const Tau = 2 * Math.PI;\r\n\r\nexport function angleClamp(v: number) {\r\n    return ((v % Tau) + Tau) % Tau;\r\n}\r\n", "import { arrayClear } from \"../collections/arrayClear\";\r\nimport type { IProgress } from \"./IProgress\";\r\n\r\nexport abstract class BaseProgress implements IProgress {\r\n    private readonly attached = new Array<IProgress>();\r\n    private soFar: number = null;\r\n    private total: number = null;\r\n    private msg: string = null;\r\n    private est: number = null;\r\n\r\n    report(soFar: number, total: number, msg?: string, est?: number): void {\r\n        this.soFar = soFar;\r\n        this.total = total;\r\n        this.msg = msg;\r\n        this.est = est;\r\n        for (const attach of this.attached) {\r\n            attach.report(soFar, total, msg, est);\r\n        }\r\n    }\r\n\r\n    attach(prog: IProgress): void {\r\n        this.attached.push(prog);\r\n        prog.report(this.soFar, this.total, this.msg, this.est);\r\n    }\r\n\r\n    end() {\r\n        this.report(1, 1, \"done\");\r\n        this.soFar = null;\r\n        this.total = null;\r\n        this.msg = null;\r\n        this.est = null;\r\n        arrayClear(this.attached);\r\n    }\r\n}", "import type { BaseParentProgressCallback } from \"./BaseParentProgressCallback\";\r\nimport { BaseProgress } from \"./BaseProgress\";\r\n\r\nexport class ChildProgressCallback extends BaseProgress {\r\n    constructor(private readonly i: number, private readonly prog: BaseParentProgressCallback) {\r\n        super();\r\n    }\r\n\r\n    override report(soFar: number, total: number, msg?: string, est?: number) {\r\n        super.report(soFar, total, msg, est);\r\n        this.prog.update(this.i, soFar, total, msg);\r\n    }\r\n}\r\n", "import { ChildProgressCallback } from \"./ChildProgressCallback\";\r\nimport type { IProgress } from \"./IProgress\";\r\n\r\nexport class BaseParentProgressCallback {\r\n    private weightTotal = 0;\r\n    private readonly start: number;\r\n\r\n    readonly subProgressCallbacks = new Array<IProgress>();\r\n    private readonly subProgressWeights = new Array<number>();\r\n    private readonly subProgressValues = new Array<number>();\r\n\r\n    constructor(private readonly prog: IProgress) {\r\n        this.start = performance.now();\r\n\r\n        for (let i = 0; i < this.subProgressWeights.length; ++i) {\r\n            this.subProgressValues[i] = 0;\r\n            this.subProgressCallbacks[i] = new ChildProgressCallback(i, this);\r\n        }\r\n    }\r\n\r\n    protected addSubProgress(weight?: number): IProgress {\r\n        weight = weight || 1;\r\n        this.weightTotal += weight;\r\n        this.subProgressWeights.push(weight);\r\n        this.subProgressValues.push(0);\r\n        const child = new ChildProgressCallback(this.subProgressCallbacks.length, this);\r\n        this.subProgressCallbacks.push(child);\r\n        return child;\r\n    }\r\n\r\n\r\n    update(i: number, subSoFar: number, subTotal: number, msg?: string) {\r\n        if (this.prog) {\r\n            this.subProgressValues[i] = subSoFar / subTotal;\r\n            let soFar = 0;\r\n            for (let j = 0; j < this.subProgressWeights.length; ++j) {\r\n                soFar += this.subProgressValues[j] * this.subProgressWeights[j];\r\n            }\r\n\r\n            const end = performance.now();\r\n            const delta = end - this.start;\r\n            const est = this.start - end + delta * this.weightTotal / soFar;\r\n            this.prog.report(soFar, this.weightTotal, msg, est);\r\n        }\r\n    };\r\n}\r\n", "import { isDefined, isFunction } from \"../typeChecks\";\r\n\r\nexport interface IProgress {\r\n    report(soFar: number, total: number, message?: string, est?: number): void;\r\n    attach(prog: IProgress): void;\r\n    end(): void;\r\n}\r\n\r\nexport function isProgressCallback(obj: any): obj is IProgress {\r\n    return isDefined(obj)\r\n        && isFunction(obj.report)\r\n        && isFunction(obj.attach)\r\n        && isFunction(obj.end);\r\n}", "import { BaseParentProgressCallback } from \"./BaseParentProgressCallback\";\r\nimport { IProgress } from \"./IProgress\";\r\n\r\nexport function progressPopper(progress: IProgress) {\r\n    return new PoppableParentProgressCallback(progress);\r\n}\r\n\r\nexport class PoppableParentProgressCallback extends BaseParentProgressCallback {\r\n    pop(weight?: number) {\r\n        return this.addSubProgress(weight);\r\n    }\r\n}\r\n", "import { TypedEvent, TypedEventBase } from \"../events/EventBase\";\r\nimport type { IProgress } from \"../progress/IProgress\";\r\nimport { isProgressCallback } from \"../progress/IProgress\";\r\nimport { assertNever, isArray, isDefined } from \"../typeChecks\";\r\nimport type { IDisposable } from \"../using\";\r\nimport type {\r\n    WorkerClientMethodCallMessage,\r\n    WorkerServerErrorMessage,\r\n    WorkerServerEventMessage,\r\n    WorkerServerMessages,\r\n    WorkerServerProgressMessage,\r\n    WorkerServerReturnMessage\r\n} from \"./WorkerMessages\";\r\n\r\ninterface WorkerInvocation {\r\n    onProgress: IProgress;\r\n    resolve: (value: any) => void;\r\n    reject: (reason?: any) => void;\r\n    methodName: string;\r\n}\r\n\r\nexport class WorkerClient<EventsT> extends TypedEventBase<EventsT> implements IDisposable {\r\n    static isSupported = \"Worker\" in globalThis;\r\n\r\n    private taskCounter = 0;\r\n    private invocations = new Map<number, WorkerInvocation>();\r\n\r\n    /**\r\n     * Creates a new pooled worker method executor.\r\n     * @param options\r\n     */\r\n    constructor(private worker: Worker) {\r\n        super();\r\n\r\n        if (!WorkerClient.isSupported) {\r\n            console.warn(\"Workers are not supported on this system.\");\r\n        }\r\n\r\n        this.worker.addEventListener(\"message\", (evt: MessageEvent<WorkerServerMessages>) => {\r\n            const data = evt.data;\r\n            switch (data.type) {\r\n                case \"event\":\r\n                    this.propogateEvent(data);\r\n                    break;\r\n                case \"progress\":\r\n                    this.progressReport(data);\r\n                    break;\r\n                case \"return\":\r\n                    this.methodReturned(data);\r\n                    break;\r\n                case \"error\":\r\n                    this.invocationError(data);\r\n                    break;\r\n                default:\r\n                    assertNever(data);\r\n            }\r\n        });\r\n    }\r\n\r\n    private postMessage(message: WorkerClientMethodCallMessage, transferables?: Transferable[]) {\r\n        if (message.type !== \"methodCall\") {\r\n            assertNever(message.type);\r\n        }\r\n\r\n        if (transferables) {\r\n            this.worker.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.worker.postMessage(message);\r\n        }\r\n    }\r\n\r\n    dispose() {\r\n        this.worker.terminate();\r\n    }\r\n\r\n    private propogateEvent(data: WorkerServerEventMessage) {\r\n        const evt = new TypedEvent(data.eventName);\r\n        this.dispatchEvent(Object.assign(evt, data.data));\r\n    }\r\n\r\n    private progressReport(data: WorkerServerProgressMessage) {\r\n        const invocation = this.invocations.get(data.taskID);\r\n        const { onProgress } = invocation;\r\n        if (onProgress) {\r\n            onProgress.report(data.soFar, data.total, data.msg, data.est);\r\n        }\r\n    }\r\n\r\n    private methodReturned(data: WorkerServerReturnMessage) {\r\n        const messageHandler = this.removeInvocation(data.taskID);\r\n        const { resolve } = messageHandler;\r\n        resolve(data.returnValue);\r\n    }\r\n\r\n    private invocationError(data: WorkerServerErrorMessage) {\r\n        const messageHandler = this.removeInvocation(data.taskID);\r\n        const { reject, methodName } = messageHandler;\r\n        reject(new Error(`${methodName} failed. Reason: ${data.errorMessage}`));\r\n    }\r\n\r\n    /**\r\n     * When the invocation has errored, we want to stop listening to the worker\r\n     * message channel so we don't eat up processing messages that have no chance\r\n     * ever pertaining to the invocation.\r\n     **/\r\n    private removeInvocation(taskID: number) {\r\n        const invocation = this.invocations.get(taskID);\r\n        this.invocations.delete(taskID);\r\n        return invocation;\r\n    }\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, params: any[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, params: any[], transferables: Transferable[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param parameters - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    callMethod<T>(methodName: string, parameters?: any[] | IProgress, transferables?: Transferable[] | IProgress, onProgress?: IProgress): Promise<T | undefined> {\r\n        if (!WorkerClient.isSupported) {\r\n            return Promise.reject(new Error(\"Workers are not supported on this system.\"));\r\n        }\r\n\r\n        // Normalize method parameters.\r\n        let params: any[] = null;\r\n        let tfers: Transferable[] = null;\r\n\r\n        if (isProgressCallback(parameters)) {\r\n            onProgress = parameters;\r\n            parameters = null;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isProgressCallback(transferables)\r\n            && !onProgress) {\r\n            onProgress = transferables;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isArray(parameters)) {\r\n            params = parameters;\r\n        }\r\n\r\n        if (isArray(transferables)) {\r\n            tfers = transferables;\r\n        }\r\n\r\n        // taskIDs help us keep track of return values.\r\n        const taskID = this.taskCounter++;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const invocation: WorkerInvocation = {\r\n                onProgress,\r\n                resolve,\r\n                reject,\r\n                methodName\r\n            };\r\n\r\n            this.invocations.set(taskID, invocation);\r\n\r\n            let message: WorkerClientMethodCallMessage = null;\r\n            if (isDefined(parameters)) {\r\n                message = {\r\n                    type: \"methodCall\",\r\n                    taskID,\r\n                    methodName,\r\n                    params\r\n                };\r\n            }\r\n            else {\r\n                message = {\r\n                    type: \"methodCall\",\r\n                    taskID,\r\n                    methodName\r\n                };\r\n            }\r\n\r\n            this.postMessage(message, tfers);\r\n        });\r\n    }\r\n}\r\n", "import { arrayClear } from \"../collections/arrayClear\";\r\nimport { TypedEventBase } from \"../events/EventBase\";\r\nimport type { IProgress } from \"../progress/IProgress\";\r\nimport { isProgressCallback } from \"../progress/IProgress\";\r\nimport { isArray, isDefined, isNullOrUndefined, isNumber } from \"../typeChecks\";\r\nimport type { IDisposable } from \"../using\";\r\nimport { WorkerClient } from \"./WorkerClient\";\r\nimport type { FullWorkerClientOptions } from \"./WorkerClientOptions\";\r\n\r\nexport type WorkerConstructorT<EventsT, WorkerClientT extends WorkerClient<EventsT>> = new (worker: Worker) => WorkerClientT;\r\n\r\nexport class WorkerPool<EventsT, WorkerClientT extends WorkerClient<EventsT>>\r\n    extends TypedEventBase<EventsT>\r\n    implements IDisposable {\r\n    static isSupported = \"Worker\" in globalThis;\r\n\r\n    private scriptPath: string;\r\n    private taskCounter: number;\r\n    protected readonly workers: WorkerClientT[];\r\n\r\n    /**\r\n     * Creates a new pooled worker method executor.\r\n     * @param options\r\n     */\r\n    constructor(options: FullWorkerClientOptions, WorkerClientClass: WorkerConstructorT<EventsT, WorkerClientT>) {\r\n        super();\r\n\r\n        this.scriptPath = options.scriptPath;\r\n\r\n        let workerPoolSize: number = -1;\r\n        const workersDef = options.workers;\r\n        let workers: Array<Worker> = null;\r\n        if (isNumber(workersDef)) {\r\n            workerPoolSize = workersDef;\r\n        }\r\n        else if (isDefined(workersDef)) {\r\n            this.taskCounter = workersDef.curTaskCounter;\r\n            workers = workersDef.workers;\r\n            workerPoolSize = workers.length;\r\n        }\r\n        else {\r\n            workerPoolSize = navigator.hardwareConcurrency || 4;\r\n        }\r\n\r\n        // Validate parameters\r\n        if (workerPoolSize < 1) {\r\n            throw new Error(\"Worker pool size must be a postive integer greater than 0\");\r\n        }\r\n\r\n        this.workers = new Array(workerPoolSize);\r\n\r\n        if (isNullOrUndefined(workers)) {\r\n            this.taskCounter = 0;\r\n            for (let i = 0; i < workerPoolSize; ++i) {\r\n                this.workers[i] = new WorkerClientClass(new Worker(this.scriptPath, { type: \"module\" }));\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < workerPoolSize; ++i) {\r\n                this.workers[i] = new WorkerClientClass(workers[i]);\r\n            }\r\n        }\r\n\r\n        for (const worker of this.workers) {\r\n            worker.addBubbler(this);\r\n        }\r\n    }\r\n\r\n    dispose() {\r\n        for (const worker of this.workers) {\r\n            worker.dispose();\r\n        }\r\n        arrayClear(this.workers);\r\n    }\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, params: any[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, params: any[], transferables: Transferable[], onProgress?: IProgress): Promise<T>;\r\n\r\n    /**\r\n     * Execute a method on a round-robin selected worker thread.\r\n     * @param methodName - the name of the method to execute.\r\n     * @param params - the parameters to pass to the method.\r\n     * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.\r\n     * @param onProgress - a callback for receiving progress reports on long-running invocations.\r\n     */\r\n    protected callMethod<T>(methodName: string, params?: any[] | IProgress, transferables?: Transferable[] | IProgress, onProgress?: IProgress): Promise<T | undefined> {\r\n        if (!WorkerClient.isSupported) {\r\n            return Promise.reject(new Error(\"Workers are not supported on this system.\"));\r\n        }\r\n\r\n        // Normalize method parameters.\r\n        let parameters: any[] = null;\r\n        let tfers: Transferable[] = null;\r\n\r\n        if (isProgressCallback(params)) {\r\n            onProgress = params;\r\n            params = null;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isProgressCallback(transferables)\r\n            && !onProgress) {\r\n            onProgress = transferables;\r\n            transferables = null;\r\n        }\r\n\r\n        if (isArray(params)) {\r\n            parameters = params;\r\n        }\r\n\r\n        if (isArray(transferables)) {\r\n            tfers = transferables;\r\n        }\r\n\r\n        const worker = this.nextWorker();\r\n\r\n        return worker.callMethod<T>(methodName, parameters, tfers, onProgress);\r\n    }\r\n\r\n    protected nextWorker() {\r\n        // taskIDs help us keep track of return values.\r\n        // The modulus selects them in a round-robin fashion.\r\n        const taskID = this.taskCounter++;\r\n        const workerID = taskID % this.workers.length;\r\n        return this.workers[workerID];\r\n    }\r\n}\r\n", "import { EventBase } from \"../events/EventBase\";\r\nimport { BaseProgress } from \"../progress/BaseProgress\";\r\nimport { isArray, isDefined } from \"../typeChecks\";\r\nimport { WorkerClientMethodCallMessage, WorkerServerErrorMessage, WorkerServerEventMessage, WorkerServerMessages, WorkerServerProgressMessage, WorkerServerReturnMessage } from \"./WorkerMessages\";\r\n\r\ntype workerServerMethod = (taskID: number, ...params: any[]) => Promise<void>;\r\n\r\ntype createTransferableCallback<T> = (returnValue: T) => Transferable[];\r\n\r\ntype Executor<T> = (...params: any[]) => Promise<T>;\r\n\r\ntype VoidExecutor = (...params: any[]) => void;\r\n\r\nclass WorkerServerProgress extends BaseProgress {\r\n    constructor(private readonly server: WorkerServer, private readonly taskID: number) {\r\n        super();\r\n    }\r\n\r\n\r\n    /**\r\n     * Report progress through long-running invocations. If your invocable\r\n     * functions don't report progress, this can be safely ignored.\r\n     * @param soFar - how much of the process we've gone through.\r\n     * @param total - the total amount we need to go through.\r\n     * @param msg - an optional message to include as part of the progress update.\r\n     * @param est - an optional estimate of how many milliseconds are left in the progress.\r\n     */\r\n    override report(soFar: number, total: number, msg?: string, est?: number): void {\r\n        const message: WorkerServerProgressMessage = {\r\n            type: \"progress\",\r\n            taskID: this.taskID,\r\n            soFar,\r\n            total,\r\n            msg,\r\n            est\r\n        };\r\n        this.server.postMessage(message);\r\n    }\r\n}\r\n\r\nexport class WorkerServer {\r\n    private methods = new Map<string, workerServerMethod>();\r\n\r\n    /**\r\n     * Creates a new worker thread method call listener.\r\n     * @param self - the worker scope in which to listen.\r\n     */\r\n    constructor(private self: DedicatedWorkerGlobalScope) {\r\n        this.self.addEventListener(\"message\", (evt: MessageEvent<WorkerClientMethodCallMessage>): void => {\r\n            const data = evt.data;\r\n            this.callMethod(data);\r\n        });\r\n    }\r\n\r\n    postMessage(message: WorkerServerMessages, transferables?: Transferable[]): void {\r\n        if (isDefined(transferables)) {\r\n            this.self.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.self.postMessage(message);\r\n        }\r\n    }\r\n\r\n    private callMethod(data: WorkerClientMethodCallMessage) {\r\n        const method = this.methods.get(data.methodName);\r\n        if (method) {\r\n            try {\r\n                if (isArray(data.params)) {\r\n                    method(data.taskID, ...data.params);\r\n                }\r\n                else if (isDefined(data.params)) {\r\n                    method(data.taskID, data.params);\r\n                }\r\n                else {\r\n                    method(data.taskID);\r\n                }\r\n            }\r\n            catch (exp) {\r\n                this.onError(data.taskID, `method invocation error: ${data.methodName}(${exp.message || exp})`);\r\n            }\r\n        }\r\n        else {\r\n            this.onError(data.taskID, `method not found: ${data.methodName}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Report an error back to the calling thread.\r\n     * @param taskID - the invocation ID of the method that errored.\r\n     * @param errorMessage - what happened?\r\n     */\r\n    private onError(taskID: number, errorMessage: string): void {\r\n        const message: WorkerServerErrorMessage = {\r\n            type: \"error\",\r\n            taskID,\r\n            errorMessage\r\n        };\r\n        this.postMessage(message);\r\n    }\r\n\r\n    /**\r\n     * Return back to the client.\r\n     * @param taskID - the invocation ID of the method that is returning.\r\n     * @param returnValue - the (optional) value to return.\r\n     * @param transferReturnValue - a mapping function to extract any Transferable objects from the return value.\r\n     */\r\n    private onReturn<T>(taskID: number, returnValue: T, transferReturnValue: createTransferableCallback<T>): void {\r\n        let message: WorkerServerReturnMessage = null;\r\n        if (returnValue === undefined) {\r\n            message = {\r\n                type: \"return\",\r\n                taskID\r\n            };\r\n        }\r\n        else {\r\n            message = {\r\n                type: \"return\",\r\n                taskID,\r\n                returnValue\r\n            };\r\n        }\r\n\r\n        if (isDefined(transferReturnValue)) {\r\n            const transferables = transferReturnValue(returnValue);\r\n            this.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.postMessage(message);\r\n        }\r\n    }\r\n\r\n    private onEvent<T>(eventName: string, evt: Event, makePayload?: (evt: Event) => T, transferReturnValue?: createTransferableCallback<T>): void {\r\n        let message: WorkerServerEventMessage = null;\r\n        if (isDefined(makePayload)) {\r\n            message = {\r\n                type: \"event\",\r\n                eventName,\r\n                data: makePayload(evt)\r\n            };\r\n        }\r\n        else {\r\n            message = {\r\n                type: \"event\",\r\n                eventName\r\n            };\r\n        }\r\n\r\n        if (message.data !== undefined\r\n            && isDefined(transferReturnValue)) {\r\n            const transferables = transferReturnValue(message.data);\r\n            this.postMessage(message, transferables);\r\n        }\r\n        else {\r\n            this.postMessage(message);\r\n        }\r\n    }\r\n\r\n    private addMethodInternal<T>(methodName: string, asyncFunc: Function, transferReturnValue?: createTransferableCallback<T>) {\r\n        if (this.methods.has(methodName)) {\r\n            throw new Error(`${methodName} method has already been mapped.`);\r\n        }\r\n\r\n        this.methods.set(methodName, async (taskID: number, ...params: any[]) => {\r\n            const onProgress = new WorkerServerProgress(this, taskID);\r\n\r\n            try {\r\n                // Even functions returning void and functions returning bare, unPromised values, can be awaited.\r\n                // This creates a convenient fallback where we don't have to consider the exact return type of the function.\r\n                const returnValue = await asyncFunc(...params, onProgress);\r\n                this.onReturn(taskID, returnValue, transferReturnValue);\r\n            }\r\n            catch (exp) {\r\n                console.error(exp);\r\n                this.onError(taskID, exp.message || exp);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Registers a function call for cross-thread invocation.\r\n     * @param methodName - the name of the function to use during invocations.\r\n     * @param asyncFunc - the function to execute when the method is invoked.\r\n     * @param transferReturnValue - an (optional) function that reports on which values in the `returnValue` should be transfered instead of copied.\r\n     */\r\n    addFunction<T>(methodName: string, asyncFunc: Executor<T>, transferReturnValue?: createTransferableCallback<T>) {\r\n        this.addMethodInternal<T>(methodName, asyncFunc, transferReturnValue);\r\n    }\r\n\r\n    /**\r\n     * Registers a function call for cross-thread invocation.\r\n     * @param methodName - the name of the function to use during invocations.\r\n     * @param asyncFunc - the function to execute when the method is invoked.\r\n     */\r\n    addVoidFunction(methodName: string, asyncFunc: VoidExecutor) {\r\n        this.addMethodInternal(methodName, asyncFunc);\r\n    }\r\n\r\n    /**\r\n     * Registers a class method call for cross-thread invocation.\r\n     * @param methodName - the name of the method to use during invocations.\r\n     * @param obj - the object on which to find the method.\r\n     * @param transferReturnValue - an (optional) function that reports on which values in the `returnValue` should be transfered instead of copied.\r\n     */\r\n    addMethod<\r\n        ClassT,\r\n        ReturnT,\r\n        MethodNameT extends keyof ClassT & string,\r\n        MethodT extends ClassT[MethodNameT]>(\r\n            methodName: MethodNameT,\r\n            obj: ClassT,\r\n            method: MethodT & Executor<ReturnT>,\r\n            transferReturnValue?: createTransferableCallback<ReturnT>): void {\r\n        this.addFunction(methodName, method.bind(obj), transferReturnValue);\r\n    }\r\n\r\n\r\n    /**\r\n     * Registers a class method call for cross-thread invocation.\r\n     * @param methodName - the name of the method to use during invocations.\r\n     * @param obj - the object on which to find the method.\r\n     */\r\n    addVoidMethod<\r\n        ClassT,\r\n        MethodNameT extends keyof ClassT & string,\r\n        MethodT extends ClassT[MethodNameT]>(\r\n            methodName: MethodNameT,\r\n            obj: ClassT,\r\n            method: MethodT & VoidExecutor): void {\r\n        this.addVoidFunction(methodName, method.bind(obj));\r\n    }\r\n\r\n\r\n    addEvent<U extends EventBase, T>(object: U, type: string, makePayload?: (evt: Event) => T, transferReturnValue?: createTransferableCallback<T>): void {\r\n        object.addEventListener(type, (evt: Event) =>\r\n            this.onEvent(type, evt, makePayload, transferReturnValue));\r\n    }\r\n}", "\uFEFFimport { IResponse } from \"./IFetcher\";\r\n\r\nexport class ResponseTranslator {\r\n    protected async translateResponse<T, U>(responseTask: Promise<IResponse<T>>, translate: (v: T) => U | Promise<U>): Promise<IResponse<U>> {\r\n        const {\r\n            status, content, contentType, contentLength, fileName, headers, date\r\n        } = await responseTask;\r\n\r\n        return {\r\n            status,\r\n            content: await translate(content),\r\n            contentType,\r\n            contentLength,\r\n            fileName,\r\n            headers,\r\n            date\r\n        };\r\n    }\r\n}\r\n", "import type { IProgress } from \"juniper-tslib\";\r\nimport { isDefined, isString, isXHRBodyInit, mapJoin, progressPopper } from \"juniper-tslib\";\r\nimport type { IFetchingService, IRequest, IRequestWithBody, IResponse } from \"./IFetcher\";\r\nimport { ResponseTranslator } from \"./ResponseTranslator\";\r\n\r\nfunction trackProgress(name: string, xhr: XMLHttpRequest, target: (XMLHttpRequest | XMLHttpRequestUpload), onProgress: IProgress, skipLoading: boolean, prevTask?: Promise<void>): Promise<void> {\r\n    return new Promise((resolve: () => void, reject: (msg: string) => void) => {\r\n        let prevDone = !prevTask;\r\n        if (prevTask) {\r\n            prevTask.then(() => prevDone = true);\r\n        }\r\n\r\n        let done = false;\r\n        let loaded = skipLoading;\r\n        function maybeResolve() {\r\n            if (loaded && done) {\r\n                resolve();\r\n            }\r\n        }\r\n\r\n        function onError(msg: string) {\r\n            return () => {\r\n                if (prevDone) {\r\n                    reject(`${msg} (${xhr.status})`);\r\n                }\r\n            }\r\n        }\r\n\r\n        target.addEventListener(\"loadstart\", () => {\r\n            if (prevDone && !done && onProgress) {\r\n                onProgress.report(0, 1, name);\r\n            }\r\n        });\r\n\r\n        target.addEventListener(\"progress\", (ev: Event) => {\r\n            if (prevDone && !done) {\r\n                const evt = ev as ProgressEvent<XMLHttpRequestEventTarget>;\r\n                if (onProgress) {\r\n                    onProgress.report(evt.loaded, Math.max(evt.loaded, evt.total), name);\r\n                }\r\n                if (evt.loaded === evt.total) {\r\n                    loaded = true;\r\n                    maybeResolve();\r\n                }\r\n            }\r\n        });\r\n\r\n        target.addEventListener(\"load\", () => {\r\n            if (prevDone && !done) {\r\n                if (onProgress) {\r\n                    onProgress.report(1, 1, name);\r\n                }\r\n                done = true;\r\n                maybeResolve();\r\n            }\r\n        });\r\n\r\n        target.addEventListener(\"error\", onError(\"error\"));\r\n        target.addEventListener(\"abort\", onError(\"abort\"));\r\n        target.addEventListener(\"timeout\", onError(\"timeout\"));\r\n    });\r\n}\r\n\r\nfunction sendRequest(xhr: XMLHttpRequest, xhrType: XMLHttpRequestResponseType, method: string, path: string, timeout: number, headers: Map<string, string>, body?: BodyInit): void {\r\n    xhr.open(method, path);\r\n    xhr.responseType = xhrType;\r\n    xhr.timeout = timeout;\r\n    if (headers) {\r\n        for (const [key, value] of headers) {\r\n            xhr.setRequestHeader(key, value);\r\n        }\r\n    }\r\n\r\n    if (isDefined(body)) {\r\n        xhr.send(body);\r\n    }\r\n    else {\r\n        xhr.send();\r\n    }\r\n}\r\n\r\nfunction readResponseHeader<T>(headers: Map<string, string>, key: string, translate: (value: string) => T): T {\r\n    if (!headers.has(key)) {\r\n        return null;\r\n    }\r\n\r\n    const value = headers.get(key);\r\n    try {\r\n        const translated = translate(value);\r\n        headers.delete(key);\r\n        return translated;\r\n    }\r\n    catch (exp) {\r\n        console.warn(key, exp);\r\n    }\r\n    return null;\r\n}\r\n\r\nconst FILE_NAME_PATTERN = /filename=\\\"(.+)\\\"(;|$)/;\r\nfunction readResponse<T>(xhr: XMLHttpRequest) {\r\n    const parts = xhr\r\n        .getAllResponseHeaders()\r\n        .split(/[\\r\\n]+/)\r\n        .map<[string, string]>(line => {\r\n            const parts = line.split(\": \");\r\n            const key = parts.shift();\r\n            const value = parts.join(\": \");\r\n            return [key, value];\r\n        })\r\n        .filter(kv => kv[0].length > 0);\r\n\r\n    const headers = new Map<string, string>(parts);\r\n\r\n    const response: IResponse<T> = {\r\n        status: xhr.status,\r\n        content: xhr.response as T,\r\n        contentType: readResponseHeader(headers, \"content-type\", v => v),\r\n        contentLength: readResponseHeader(headers, \"content-length\", parseFloat),\r\n        fileName: readResponseHeader(headers, \"content-disposition\", v => {\r\n            if (isDefined(v)) {\r\n                const match = v.match(FILE_NAME_PATTERN);\r\n                if (isDefined(match)) {\r\n                    return match[1];\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }),\r\n        date: readResponseHeader(headers, \"date\", v => new Date(v)),\r\n        headers\r\n    };\r\n\r\n    return response;\r\n}\r\n\r\nexport class FetchingServiceImpl\r\n    extends ResponseTranslator\r\n    implements IFetchingService {\r\n\r\n    private readonly defaultPostHeaders = new Map<string, string>();\r\n\r\n    setRequestVerificationToken(value: string): void {\r\n        this.defaultPostHeaders.set(\"RequestVerificationToken\", value);\r\n    }\r\n\r\n    private async headOrGetXHR<T>(method: string, xhrType: XMLHttpRequestResponseType, request: IRequest, progress: IProgress): Promise<IResponse<T>> {\r\n        const xhr = new XMLHttpRequest();\r\n        const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, progress, true);\r\n\r\n        sendRequest(xhr, xhrType, method, request.path, request.timeout, request.headers);\r\n\r\n        await download;\r\n        return readResponse(xhr);\r\n    }\r\n\r\n    private getXHR<T>(xhrType: XMLHttpRequestResponseType, request: IRequest, progress: IProgress): Promise<IResponse<T>> {\r\n        return this.headOrGetXHR(\"GET\", xhrType, request, progress);\r\n    }\r\n\r\n    head(request: IRequest): Promise<IResponse<void>> {\r\n        return this.headOrGetXHR(\"HEAD\", \"\", request, null);\r\n    }\r\n\r\n    private async postXHR<T>(xhrType: XMLHttpRequestResponseType, request: IRequestWithBody, prog: IProgress): Promise<IResponse<T>> {\r\n\r\n        let body: BodyInit = null;\r\n\r\n        \r\n        const headers = mapJoin(new Map<string, string>(), this.defaultPostHeaders, request.headers);\r\n\r\n        if (request.body instanceof FormData\r\n            && isDefined(headers)) {\r\n            const toDelete = new Array<string>();\r\n            for (const key of headers.keys()) {\r\n                if (key.toLowerCase() === \"content-type\") {\r\n                    toDelete.push(key);\r\n                }\r\n            }\r\n            for (const key of toDelete) {\r\n                headers.delete(key);\r\n            }\r\n        }\r\n\r\n        if (isXHRBodyInit(request.body) && !isString(request.body)) {\r\n            body = request.body;\r\n        }\r\n        else if (isDefined(request.body)) {\r\n            body = JSON.stringify(request.body);\r\n        }\r\n\r\n        const progs = progressPopper(prog);\r\n        const xhr = new XMLHttpRequest();        \r\n        const upload = isDefined(body)\r\n            ? trackProgress(\"uploading\", xhr, xhr.upload, progs.pop(), false)\r\n            : Promise.resolve();\r\n        const download = trackProgress(\"saving\", xhr, xhr, progs.pop(), true, upload);\r\n\r\n        sendRequest(xhr, xhrType, \"POST\", request.path, request.timeout, headers, body);\r\n\r\n        await upload;\r\n        await download;\r\n        return readResponse(xhr);\r\n    }\r\n\r\n    getBlob(request: IRequest, progress: IProgress): Promise<IResponse<Blob>> {\r\n        return this.getXHR<Blob>(\"blob\", request, progress);\r\n    }\r\n\r\n    postObjectForBlob(request: IRequestWithBody, progress: IProgress): Promise<IResponse<Blob>> {\r\n        return this.postXHR<Blob>(\"blob\", request, progress);\r\n    }\r\n\r\n    getBuffer(request: IRequest, progress: IProgress): Promise<IResponse<ArrayBuffer>> {\r\n        return this.getXHR<ArrayBuffer>(\"arraybuffer\", request, progress);\r\n    }\r\n\r\n    postObjectForBuffer(request: IRequestWithBody, progress: IProgress): Promise<IResponse<ArrayBuffer>> {\r\n        return this.postXHR<ArrayBuffer>(\"arraybuffer\", request, progress);\r\n    }\r\n\r\n    getText(request: IRequest, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.getXHR<string>(\"text\", request, progress);\r\n    }\r\n\r\n    postObjectForText(request: IRequestWithBody, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.postXHR<string>(\"text\", request, progress);\r\n    }\r\n\r\n    async getObject<T>(request: IRequest, progress: IProgress): Promise<T> {\r\n        const response = await this.getXHR<T>(\"json\", request, progress);\r\n        return response.content;\r\n    }\r\n\r\n    async postObjectForObject<T>(request: IRequestWithBody, progress: IProgress): Promise<T> {\r\n        const response = await this.postXHR<T>(\"json\", request, progress);\r\n        return response.content;\r\n    }\r\n\r\n    postObject(request: IRequestWithBody, progress: IProgress): Promise<IResponse<void>> {\r\n        return this.postXHR<void>(\"\", request, progress);\r\n    }\r\n\r\n    getFile(request: IRequest, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.translateResponse(\r\n            this.getBlob(request, progress),\r\n            URL.createObjectURL);\r\n    }\r\n\r\n    postObjectForFile(request: IRequestWithBody, progress: IProgress): Promise<IResponse<string>> {\r\n        return this.translateResponse(\r\n            this.postObjectForBlob(request, progress),\r\n            URL.createObjectURL);\r\n    }\r\n\r\n    getXml(request: IRequest, progress: IProgress): Promise<IResponse<HTMLElement>> {\r\n        return this.translateResponse(\r\n            this.getXHR<Document>(\"document\", request, progress),\r\n            doc => doc.documentElement);\r\n    }\r\n\r\n    postObjectForXml(request: IRequestWithBody, progress: IProgress): Promise<IResponse<HTMLElement>> {\r\n        return this.translateResponse(\r\n            this.postXHR<Document>(\"document\", request, progress),\r\n            doc => doc.documentElement);\r\n    }\r\n\r\n    getImageBitmap(request: IRequest, progress: IProgress): Promise<IResponse<ImageBitmap>> {\r\n        return this.translateResponse(\r\n            this.getBlob(request, progress),\r\n            createImageBitmap)\r\n    }\r\n\r\n    async postObjectForImageBitmap(request: IRequestWithBody, progress: IProgress): Promise<IResponse<ImageBitmap>> {\r\n        return this.translateResponse(\r\n            this.postObjectForBlob(request, progress),\r\n            createImageBitmap);\r\n    }\r\n}\r\n", "import { FetchingServiceImpl } from \"juniper-fetcher-base/FetchingServiceImpl\";\r\nimport type { IFetchingService, IResponse } from \"juniper-fetcher-base/IFetcher\";\r\nimport { WorkerServer } from \"juniper-tslib\";\r\n\r\nexport class FetchingServiceServer extends WorkerServer {\r\n    constructor(self: DedicatedWorkerGlobalScope) {\r\n        super(self);\r\n\r\n        const fetcher = new FetchingServiceImpl();\r\n        addFetcherMethods(this, fetcher);\r\n    }\r\n}\r\n\r\nfunction getContent<T extends Transferable>(response: IResponse<T>): Array<Transferable> {\r\n    return [response.content];\r\n}\r\n\r\nexport function addFetcherMethods(server: WorkerServer, fetcher: IFetchingService) {\r\n    server.addVoidMethod(\"setRequestVerificationToken\", fetcher, fetcher.setRequestVerificationToken);\r\n\r\n    server.addMethod(\"getBuffer\", fetcher, fetcher.getBuffer, getContent);\r\n    server.addMethod(\"postObjectForBuffer\", fetcher, fetcher.postObjectForBuffer, getContent);\r\n    server.addMethod(\"getImageBitmap\", fetcher, fetcher.getImageBitmap, getContent);\r\n    server.addMethod(\"postObjectForImageBitmap\", fetcher, fetcher.postObjectForImageBitmap, getContent);\r\n\r\n    server.addMethod(\"getObject\", fetcher, fetcher.getObject);\r\n    server.addMethod(\"getFile\", fetcher, fetcher.getFile);\r\n    server.addMethod(\"getText\", fetcher, fetcher.getText);\r\n    server.addMethod(\"postObject\", fetcher, fetcher.postObject);\r\n    server.addMethod(\"postObjectForObject\", fetcher, fetcher.postObjectForObject);\r\n    server.addMethod(\"postObjectForFile\", fetcher, fetcher.postObjectForFile);\r\n    server.addMethod(\"postObjectForText\", fetcher, fetcher.postObjectForText);\r\n\r\n    server.addMethod(\"head\", fetcher, fetcher.head);\r\n}\r\n", "import { FetchingServiceServer } from \"./FetchingServiceServer\";\r\n(globalThis as any).server = new FetchingServiceServer((globalThis as any) as DedicatedWorkerGlobalScope);"],
  "mappings": "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",
  "names": []
}
